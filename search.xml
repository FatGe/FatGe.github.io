<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一言难尽的 JS Coercion]]></title>
    <url>%2F2019%2F08%2F02%2Fjs-coercion%2F</url>
    <content type="text"><![CDATA[题目来源：http://javascript-puzzlers.herokuapp.com/。 来来来，小火汁，先用下面六道题目来试试水 1234567let a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log("wut");&#125;//log false 12'5' + 3; // log "53"'5' - 3; // log "2" 1234let a = [1,2];let b = [3,4];a + b; // "1,23,4" 1232 == [[[2]]]// log true 12345[] == []// log false[] == ![]// log true 12345678910let a = [1, 2, 3];let b = [1, 2, 3];let c = [1, 2, 4];a == b;a === b;a &gt; c;a &lt; c;// log false, false, false, true 细心的你一定看出来了，上述五道题目都与 JS 的类型相关，再细一点的话，应该是与类型转换相关。 引用 You Don’t Know JS 的结论，我们可以将类型转换分为：隐式转换（Implicit coercion）、显式转换（Explicit coercion）。 显式转换我们主动的将一些变量按照我们的期望进行转变。那么有几种方法呢？ ToNumer 参考 https://www.ecma-international.org/ecma-262/5.1/#sec-9.3。 其他类型转换为 number 类型的几种方法 输入类型结果 UndefinedNaN Null+0 Boolean如果参数是 true，结果为 1。如果参数是 false，此结果为 +0。 Number结果等于输入的参数（不转换）。 Stringstring ---> number Object object ---> number string —&gt; number 这个过程类似于判断字符串是否为一个字符串数值常量，例如 1234567let a = '1'let b = 'hello world'console.log(Number(a)) // 1console.log(Number(b)) // NaNconsole.log(+a) // 1console.log(+b) // NaN 其中，在开源的 JS 社区中一般将 + 视为一个 明确的 强制转换形式。 同时，这个转换过程中也包含着一些细节，类似于 Number(&quot;&quot;) // 0 等，具体可见 https://www.ecma-international.org/ecma-262/5.1/#sec-9.3.1。 Number(a) 可以的话，那么 new Number(a) 可以么？可见 https://juejin.im/post/5d37adcff265da1bb13f7347。 object —&gt; number 这个过程可以分为两部，object –&gt; ToPrimitive(object) –&gt; number。 ToPrimitive 运算符把其值参数转换为非对象类型，也就是调用其内部的 [[DefaultValue]] 方法。 [[DefaultValue]] (hint) 中 hint 为期望类型（很关键）： 如果 hint 为 number：先 Object.prototype.valueOf ，如果结果为原始值，则返回，否则调用 Object.prototype.toString； 如果 hint 为 string：先 Object.prototype.toString ，如果结果为原始值，则返回，否则调用 Object.prototype.valueOf 。 1234567var a = &#123; valueOf: function() &#123; return 42; &#125;, toString: function() &#123; return 4; &#125;&#125;;console.log(Number(a)) // 42console.log(String(a)) // 4 ToString https://www.ecma-international.org/ecma-262/5.1/#sec-9.8 输入类型结果 Undefined"undefined" Null"null" Boolean如果参数是 true，那么结果为 "true"。 如果参数是 false，那么结果为 "false"。 String结果等于输入的参数（不转换）。 Number见 number--->string Object见上文。 number —&gt; string 与 string —&gt; number 类似，大体上是将字符串数值常量转为字符串，其中有些科学计数法的转化细节 1String(1e-1) // "0.1" 还有一些 NaN 的细节，见参考。 ToBoolean https://www.ecma-international.org/ecma-262/5.1/#sec-9.2 相对于前两个，ToBoolean 的规则较为明确 输入类型结果 Undefinedfalse Nullfalse Boolean结果等于输入的参数（不转换）。 Number如果参数是 +0, -0, 或 NaN，结果为 false ；否则结果为 true。 String如果参数参数是空字符串（其长度为零），结果为 false，否则结果为 true。 Objecttrue 除了几个特殊的 undefined，null，0，&quot;&quot;，NaN，其他的一律转为 true。主要的转换方法，Boolean 以及 !!。 123456789101112131415161718192021222324let a = "0";let b = [];let c = &#123;&#125;;let d = "";let e = 0;let f = null;let g;Boolean( a ); // true!!a; // trueBoolean( b ); // true!!a; // trueBoolean( c ); // true!!c; // trueBoolean( d ); // false!!d; // falseBoolean( e ); // false!!e; // falseBoolean( f ); // false!!f; // falseBoolean( g ); // false!!g; // false 隐式转换（一般伴随着表达式、操作符）当我们在使用条件表达式或者一些运算、相等操作符时，如果不注意，就会发生隐式的类型转换。 判断语句主要有一下五种情况。 在一个if (..)语句中的条件表达式； 在一个for ( .. ; .. ; .. ) 中间的条件表达式； 在 while (..) 和 do..while(..) 循环中的条件表达式； 在? :三元表达式中的条件表达式（第一个子句）； ||（“逻辑或”）和&amp;&amp;（“逻辑与”）操作符左手边的操作数。 在日常的开发中，我们通常不会将判断语语句中的 condition 的结果强制转换为 boolean，例如 12345678910let a = 42let b = &#123;&#125;if (a) &#123; console.log( "yep" ); // yep&#125;while (b) &#123; console.log( "forever running" );&#125; 这时我们已经默认使用隐式转换来简化代码。而在没有默认参数的 ES5，我们也会使用，来为函数添加默认参数 1234let a;let b = 42;a || b; // 42 或者利用 &amp;&amp; 来简化 if 语句 1234let a = 42;let b = "abc";a &amp;&amp; b; // "abc" 所以在第一道题目中 12345let a = [0];if ([0]) &#123; console.log(a == true);&#125;// [0] 会转化为 true +、- 运算符 https://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1 根据ES5语言规范，如果两个操作数之一已经是一个 string，或者下列步骤产生一个 string 表达形式，+ 将会进行连接。 所以题目中 1'5' + 3; // log "53" 但，如果当 + 的两个操作数之一收到一个object（包括array）时，它首先在这个值上调用 ToPrimitive，例如 1'5' + [1,2,3] // "51,2,3" 会将 [1,2,3] 转为了 string 调用 toString，至于原因见上文。 所以第三题目中，a 和 b 分别被转化为 &quot;1,2&quot; 以及 &quot;3,4&quot; 1234let a = [1,2];let b = [3,4];a + b; // "1,23,4" 而一元 - 运算符将其操作数转换为 number 类型，所以 1'5' - 3; // log 2 == 以及 === 相等操作符 https://www.ecma-international.org/ecma-262/5.1/#sec-11.9.1 最为常考，开发用的少，面试用的多的 == 来了，这里引用一句You Don’t Know JS 中的一句话 “== allows coercion in the equality comparison and === disallows coercion.” == 与 === 的本质区别在与 coercion 也就是说本质在于是否发生了强制类型转换。那么 == 是如何转化类型的呢？ 以 x == y 为例（篇幅所限省略，x、y 类型相同的规则，见参考地址） x 为 null 且 y 为 undefined， 返回 true; x 为 undefined 且 y 为 null，返回 true; 若 Type(x) 为 number 且 Type(y) 为 string，返回 x == ToNumber(y) 的结果; Type(x) 为 string 且 Type(y) 为 number，返回 ToNumber(x) == y的结果; Type(x) 为 boolean，返回 ToNumber(x) == y 的结果; Type(y) 为 boolean，返回 x == ToNumber(y) 的结果; Type(x) 为 string 或 number，且 Type(y) 为 object，返回 x == ToPrimitive(y) 的结果; Type(x) 为 object 且 Type(y) 为 string 或 number， 返回比较ToPrimitive(x) == y 的结果。 看似很多，其实本质上满足两条： 如果 x，y 的类型为非引用类型，将其转化为 number 进行对比； 如果 x，y 的类型为引用类，将调用 ToPrimitive 转化为基础值进行对比。 1232 == '2' // true1 == true // true0 == false // true 而题目中，[[[2]]] 需要获取 ToPrimitive 的结果 12342 == [[[2]]]// [[[2]]] 调用 valueOf() 得到 [Array(1)] 非基础类型// [[[2]]] 调用 toString() 得到 2// log true 123456789[] == []// [] 与 [] 类型都为 object，所以比对是否引用同一个对象// false[] == ![]// ![] 强制转化为 boolean，false，// ![] 转化为 boolean，所以 [] 需要利用 ToPrimitive 得到 ""// 原式变为 "" == false，false 转化为 0，而 "" 也变为 0// log true 同样还有 &gt;，&lt; https://www.ecma-international.org/ecma-262/5.1/#sec-11.8 12345678910let a = [1, 2, 3];let b = [1, 2, 3];let c = [1, 2, 4];a == b; // 非同一引用a === b; // 非同一引用a &gt; c; // a 转化为 "1,2,3"，c 转化为 "1,2,4"a &lt; c;// log false, false, false, true]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Profiler 分析 Vue Render 性能问题]]></title>
    <url>%2F2019%2F07%2F30%2Fprofile-analyse-vue%2F</url>
    <content type="text"><![CDATA[最近在开发一套组件库，期间在实现InputNumber 组件时候碰到一个诡异卡顿的现象，用了时间来排除这个问题，涉及到一些问题定位的方法，记录下来已备后用。 1. 发现问题在实现 InputNumber 组件的时候，有一个功能是按住 + 或 - 按钮时，组件的值在不断的自增或者自减，当组件的值自增到一定数量之后，组件会开始卡顿，并且页面上下滚动也会有明显的延迟。 问题体验 相关代码 2. 定位问题12345678910111213141516171819202122232425262728&lt;script&gt;export default &#123; name: "input-number", ... methods: &#123; handleClick(type) &#123; const &#123; step &#125; = this; const period = 10; const timerHandle = () =&gt; &#123; const &#123; addDisabled, decDisabled &#125; = this; if (!addDisabled &amp;&amp; type === "add") this.inputNumberValue += step; if (!decDisabled &amp;&amp; type === "dec") this.inputNumberValue -= step; &#125;; const timer = setInterval(timerHandle, period); const startTime = new Date(); const handler = () =&gt; &#123; const endTime = new Date(); if (endTime - startTime &lt; period) timerHandle(); clearInterval(timer); document.removeEventListener("mouseup", handler, false); &#125;; document.addEventListener("mouseup", handler, false); &#125; ...&#125;;&lt;/script&gt; 首先定位问题发生的位置，直观上感受应该是点击之后不无端自增发生的卡顿，对应代码中的 handleClick 函数，它将 click 事件分为 mousedown 以及 mouseup，当触发 mousedown 事件时候，调用一个 setInterval 定时执行组件值变化的函数。 初步定位问题应该就发生在 timerHandle 之后，当 inputNumberValue 发生变化之后，它会按照一定的规则来改变 inputValue 的值，从而触发 $emit(input, this.inputValue) 来完成 v-model。 1234567891011121314151617181920212223computed: &#123; inputNumberValue: &#123; get() &#123; return this.inputValue; &#125;, set(value) &#123; // ...一定规则 this.inputValue = limits.find(limit =&gt; limit.need(value)).value; &#125; &#125;&#125;,watch: &#123; value: &#123; handler(newVal) &#123; console.timeEnd() this.inputNumberValue = newVal; &#125;, immediate: true &#125;, inputValue(newVal) &#123; this.$emit("input", newVal); &#125;&#125; 利用 console.time 以及 console.timeEnd 来排查，那一步发生的卡顿，检测整个 v-model 变化的流程。 也就是在 timerHandle 以及 watch value handler 内添加 console.time 以及 console.timeEnd ，具体如下 12345678910111213141516const timerHandle = () =&gt; &#123; const &#123; addDisabled, decDisabled &#125; = this; if (!addDisabled &amp;&amp; type === "add") this.inputNumberValue += step; if (!decDisabled &amp;&amp; type === "dec") this.inputNumberValue -= step; console.time();&#125;;watch: &#123; value: &#123; handler(newVal) &#123; console.timeEnd() this.inputNumberValue = newVal; &#125;, immediate: true &#125;&#125; 然后运行，发现运行时间是在不断地增加的，这时候问题的可以归类为，inputNumber 组件的值在不断地变动，导致的 update 的时间会不断地增长。 接下来要判断具体是哪一句js导致整个页面的 update 时间不断地变长，利用 Chrome 的 JavaScript Profiler 来完成该工作。打开开发者工具 利用这个面板你可以追踪网页程序的内存泄漏问题，进一步提升程序的JavaScript执行性能，点击Start 按钮，然后去复现刚才的操作，得到结果如下 图中标识处有三个模式： Chart 按时间先后顺序显示的火焰图； Heavy(Bottom Up) 根据对性能的消耗影响列出所有的函数，并可以查看该函数的调用路径； Tree(Top Down) 从调用栈的顶端（最初调用的位置）开始，显示调用结构的总体的树状图情况。 选择 Tree(Top Down) 模式，得到结果如下 可以看出 flushCallbacksvue 函数占用了74.66%的 Total Time，所以需要对它进行分析 在它的调用栈中，关键的一步是 Vue._update ，它的主要功能是将 Vnode 渲染成真实DOM，所以上述的卡顿问题果然出现在渲染这一步。 继续分析，发现主要问题在与 updateDirctives 这个函数内，看来问题和指令的更新相关。 最后，发现原来是 highlightBlock 的锅，因为要完成页面中代码高亮的需求，开发了一个指令 12345678import hljs from 'highlight.js/lib/highlight';Vue.directive ('highlight', function (el) &#123; let blocks = el.querySelectorAll ('code'); Array.prototype.forEach.call (blocks, block =&gt; &#123; hljs.highlightBlock (block); &#125;);&#125;); 当 InputNumber 组件 v-model 所绑定的父组件 data 变动时候，会导致 v-highlight 指令不断地更新，使得页面卡顿。 3. 解决问题只需要将该指令的高亮代码的函数写在 bind 里面，这样就只调用一次，指令第一次绑定到元素时调用。 12345678Vue.directive ('highlight', &#123; bind (el) &#123; let blocks = el.querySelectorAll ('code'); Array.prototype.forEach.call (blocks, block =&gt; &#123; hljs.highlightBlock (block); &#125;); &#125;&#125;); 欢迎Star：https://github.com/FatGe/FatGe.github.io]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React v16 生命周期函数详解：如何、何时使用它们（React 组件生命周期的修订和最新指南）]]></title>
    <url>%2F2019%2F07%2F26%2Freact-lifecycle%2F</url>
    <content type="text"><![CDATA[翻译自 React 16 Lifecycle Methods: How and When to Use Them，作者：Scott Domes 参考 React.Component 概述：最近在学习 react v16.8.4，发现组件的生命周期发生了一些变化，原有的一些方法被废弃，所以看了官方API介绍，再结合上述文章，做个总结。 由于这次生命周期 API 有点复杂，我将这些方法分为四个部分：安装（Mounting），更新（Updating），卸载（Unmounting）和异常（Error）。 Mounting - 组件的挂载├── constructor ├── static getDerivedStateFromProps ├── render ├── componentDidMount constructor 如果您的组件是 Class Component，则调用的第一就是组件构造函数。 这不适用于 Functional Component。 相关构造函数可能是如下形式 12345678class MyComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; counter: 0, &#125;; &#125;&#125; 构造函数的参数为 props，你可以利用 super 来传入。 在构造函数中，你可以初始化 state、设定默认值。甚至你可以依据 props 来创建 state。 12345678class MyComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; counter: props.initialCounterValue, &#125;; &#125;&#125; 注意，现在构造函数是可选的，如果您的 Babel 设置支持 class fields，就可以像这样初始化状态： 12345class MyComponent extends Component &#123; state = &#123; counter: 0, &#125;;&#125; 这种方法是被大家所提倡的。 你仍然可以根据 props 创建 state： 12345class MyComponent extends Component &#123; state = &#123; counter: this.props.initialCounterValue, &#125;;&#125; 但是，如果需要使用 ref ，就仍需要构造函数。 12345678910class Grid extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; blocks: [], &#125;; // 在 constructor 中创建 ref this.grid = React.createRef(); &#125;&#125; 我们需要构造函数来调用 createRef，以创建对 HTMLElement 元素的引用。还可以使用构造函数进行函数绑定，这也是可选的 123456789101112class Grid extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; blocks: [], &#125;; // 1 this.handleChange.bind(this) &#125; // 2 等同于 1 handleChange = () =&gt; &#123;&#125;&#125; constructor总结： 构造函数的最常法：设置 state，创建 ref 和方法绑定。 getDerivedStateFromProps 挂载时，getDerivedStateFromProps 是渲染前调用的最后一个方法 一般使用 getDerivedStateFromProps 可以根据初始 props 使用它来设置状态。 12345static getDerivedStateFromProps(props, state) &#123; return &#123; blocks: createBlocks(props.numberOfBlocks) &#125;;&#125;// log &#123;blocks: Array(20)&#125;console.log(this.state); 上述代码中依据 props.numberOfBlocks 来初始化期望的 state（函数return为状态）。 注意： 我们可以将此代码放在 constructor 中，与之相 getDerivedStateFromProps的优点是它更直观 - 它仅用于设置状态，而构造函数有多种用途。 总结： getDerivedStateFromProps 的最常见用例（在mount期间）：根据初始props返回状态对象。 render完成所有渲染的工作。它返回实际组件的 JSX，使用React时，将花费大部分时间在这里。 渲染的最常见用例：返回 JSX 组件。 componentDidMount 在第一次渲染组件之后，触发此方法。 如果需要加载数据，请在此处执行。 不要尝试在 constructor 中加载数据或渲染，原因，react-interview-questions. 由于AJAX是异步的，所以无法保证在组件挂载之前 AJAX 请求完成解析。 如果确实如此，那就意味着你要在未挂载的组件上尝试 setState，这不仅不起作用，而且 React 报错。 在componentDidMount中执行 AJAX 将保证有一个要更新的组件。 componentDidMount 触发时，组件已完成第一 render，所以可以进行一些操作： 在刚刚渲染的 &lt;canvas&gt; 元素上进行绘制 访问 DOM 节点 添加事件侦听器 基本上，在这里你可以做所有依赖 DOM 的设置，并开始获得你需要的所有数据，例如 123456789componentDidMount() &#123; // 利用 ref 访问 dom 元素 this.bricks = initializeGrid(this.grid.current); this.interval = setInterval(() =&gt; &#123; // ajax 获取数据 this.addBlocks(); &#125;, 2000); &#125;&#125; 总结： 调用 AJAX 以加载组件的数据。 Updating - 组件的更新├── static getDerivedStateFromProps ├── shouldComponentUpdate ├── render ├── getSnapshotBeforeUpdate ├── componentDidUpdate getDerivedStateFromProps 是的，再来一次。 现在，它更有用了。 如果您需要根据 props 来更新 state，可以通过 return 新的状态对象来完成该任务。 注，不建议依据 props 来处理 state，也就是说，只有逼不得已才使用该方法。 以下是一些例子： 当 video 、audio 的 source 改变时，需要重置元素； Server 资源更新后需要恢复 UI 元素； 当内容改变时关闭相关元素。 即使有上述情况，通常也有更好的方法。 但是 getDerivedStateFromProps 可以情况变得更坏。 总结： getDerivedStateFromProps 一般用于 props 不足以支撑业务时，利用它来更新 state。 shouldComponentUpdate 典型的 React 哲学，当一个组件收到新的 State 或 Props时，它应该更新。 但我们的组件有点困惑，它不确定是否要进行更新。 shouldComponentUpdate 方法的第一个参数为 nextProps，第二个参数为 nextState。shouldComponentUpdate 返回一个布尔值，用于控制组件是否更新。 shouldComponentUpdate 赋予我们一项能力，只有在你关心的 props 改变时组件会才更新。 总结： 可以准确地控制组件重新渲染的时间，常用于优化 React，具体。 render - 同上getSnapshotBeforeUpdate 新添加的方法，触发时刻在 render 之后，最新的渲染输出提交给 DOM 之前。 调用渲染和最后显示更改之间可能会有延迟， 如果你需要获取 DOM 改变之前的一些信息时，可以利用这个钩子函数。 从渲染到提交这个过程是异步的，所以如果在 componentWillUpdate 访问 DOM 信息，在 componentDidUpdate 使用时，该信息可能发生了修改，这一部分以官网的例子来说明 123456789101112131415161718192021222324252627class ScrollingList extends React.Component &#123; listRef = React.createRef(); getSnapshotBeforeUpdate(prevProps, prevState) &#123; // 如果在列表中添加新项目 // 获取列表的当前高度，以便我们稍后调整滚动 if (prevProps.list.length &lt; this.props.list.length) &#123; return this.listRef.current.scrollHeight; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // 如果我们 snapshot 的值不为空，说明添加了新项目 // 调整滚动，以便这些新项目不会将旧项目推出可视区域 if (snapshot !== null) &#123; this.listRef.current.scrollTop += this.listRef.current.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; 总结： 查看当前 DOM 的某些属性，并将该值传递给componentDidUpdat。 componentDidUpdate 所有的改变都已经提交给 DOM。 componentDidUpdate 包含三个参数，之前的 props、state，以及 getSnapshotBeforeUpdate 的返回值，具体如上述例子。 总结： 对已经改变的 Dom 作出相关响应。 UnmountingcomponentWillUnmount 组件快要结束了。 在组件注销之前，它会询问您是否有任何最后一刻的请求。 您可以在此处取消任何传出网络请求，或删除与该组件关联的所有事件侦听器。 基本上，清理任何事情都只涉及有问题的组件 - 当它消失时，它应该完全消失。 总结： 清除事件监听、定时器等，防止内存泄漏。 ErrorsgetDerivedStateFromError 发生了一些异常。 它能够捕捉在他们的子组件树中任意地方的 JavaScript 错误，记录这些错误。当我们要展示一个 error 页面时，可以利用它来完成。 123static getDerivedStateFromError(error) &#123; return &#123; hasError: true &#125;;&#125; 注意： 您必须返回更新的状态对象。 不要将此方法用于任何副作用。 而是使用下面的 componentDidCatch。 总结： 依据错误信息来修改组件的 state，同时展示出 error 页面。 componentDidCatch 与上面非常相似，因为它在子组件中发生错误时被触发。 与 getDerivedStateFromError 区别在于不是为了响应错误而更新状态，可以执行任何副作用，例如记录错误。 123componentDidCatch(error, info) &#123; sendErrorLog(error, info);&#125; 注意： componentDidCatch 仅会捕获渲染/生命周期方法中的错误。 如果在单击处理程序中引发错误，则不会捕获它。 通常只在特殊的地方使用错误边界组件的 componentDidCatch。 这些组件包装子树的唯一目的是捕获和记录错误。 123456789101112131415class ErrorBoundary extends Component &#123; state = &#123; errorMessage: null &#125;; static getDerivedStateFromError(error) &#123; return &#123; errorMessage: error.message &#125;; &#125; componentDidCatch(error, info) &#123; console.log(error, info); &#125; render() &#123; if (this.state.errorMessage) &#123; return &lt;h1&gt;Oops! &#123;this.state.errorMessage&#125;&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 总结： 捕获、打印出错误信息。 总结以上是React v16的生命周期钩子所适用的场景和具体使用方法。]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lodash 是如何做类型检测的]]></title>
    <url>%2F2019%2F07%2F21%2Flodash-type-detection%2F</url>
    <content type="text"><![CDATA[JS 的基本数据类型有 Number，String，Boolean，Symbol，Null，Undefined，六种数据类型。一种引用类型 object。 基本数据类型Number数值，根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。它并没有为整数给出一种特定的类型。 除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 对应 lodash 中的检测函数有 isNumber 检查 value 是否是原始 Number 数值型 或者 对象； isInteger 检查 value 是否为一个整数； isNaN 检测 value 是否为 NaN； isFinite 检测 value 是否是原始有限数值。 isNumber1234function isNumber(value) &#123; return typeof value == 'number' || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Number]')&#125; typeof 操作符可以返回一个字符串，表示未经计算的操作数的类型。对于 Number、String、Boolean、Undefined、String 可以很明确的得到它的类型。 那么 lodash 为什么还要添加 (isObjectLike(value) &amp;&amp; getTag(value) == &#39;[object Number]&#39;)？ 原因在于，JS 中也允许我们以如下形式创建一个数值 123const value = new Number(1)console.log(value) // log 1console.log(typeof value) // log "object" 这时，单单只是使用 typeof 操作符就没法判断 value 的类型是否为数值。所以要结合以下两个函数来判断，value 是否为 object 然后再通过过 toString() 来获取每个对象的类型。 12345678910function getTag(value) &#123; if (value == null) &#123; return value === undefined ? '[object Undefined]' : '[object Null]' &#125; return Object.prototype.toString.call(value) &#125;function isObjectLike(value) &#123; return typeof value == 'object' &amp;&amp; value !== null&#125; Object.prototype.toString.call 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。 isInteger12345function isInteger(value) &#123; return typeof value == 'number' &amp;&amp; value == toInteger(value);&#125; 检查 value 是否为一个整数，判断是否 value 的类型是否为数值，并且是否与 Int 型相同。其取整过程如下 1234567function toInteger(value) &#123; var result = toFinite(value), remainder = result % 1; return result === result ? (remainder ? result - remainder : result) : 0;&#125; isNaN检查 value 是否是 NaN。 123function isNaN(value) &#123; return isNumber(value) &amp;&amp; value != +value;&#125; 与 ES 2015 的 isNaN 不同的是，对于 undefined，{}，原生的结果是 true，而 lodash 为 false。这是因为如果isNaN函数的参数不是Number类型， isNaN函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。 12345// js native isNaNvar isNaN = function(value) &#123; var n = Number(value); return n !== n;&#125;; 但是无论是 ES 2015 还是 lodash，它们本质上都是利用 x != x 来判断 NaN。 isFinite检查 value 是否是原始有限数值。 1234function isFinite(value) &#123; return typeof value == 'number' &amp;&amp; nativeIsFinite(value);&#125; 利用原生的 isFinite 结合 typeof 判断数字是否为有限值。 StringString 类型用于表示由零或多个16 位Unicode 字符组成的字符序列，即字符串。用于保存可以以文本形式表示的数据非常有用。 值得注意的是，不单单要注意基本字符串，还需要注意字符串对象，字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。 JavaScript会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。 与之前的 number 类似，利用构造函数 String 创建的字符串是一个 object 12345const s_prim = "foo";const s_obj = new String(s_prim);console.log(typeof s_prim); // Logs "string"console.log(typeof s_obj); // Logs "object" 所以检测字符串，除了基本字符串以外还要注意字符串对象。 123456789function isString(value) &#123; const type = typeof value return type == 'string' || (type == 'object' &amp;&amp; value != null &amp;&amp; !Array.isArray(value) &amp;&amp; getTag(value) == '[object String]')&#125; 可以利用 typeof 检测基本字符串，对于模板字符串采用了之前介绍的方案 getTag 来获取 value 的类型。 BooleanBoolean 类型是ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。同样也需要区分基本的 Boolean 类型以及 Boolean 对象。 123456function isBoolean(value) &#123; return value === true || value === false || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Boolean]')&#125; 大部分在之前都已经涉及到了，这里出现了 isObjectLike，那么它是做什么的。 123function isObjectLike(value) &#123; return typeof value == 'object' &amp;&amp; value !== null&#125; 原来只是检测是否是一个非 null 的对象。 SymbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol 值通过Symbol函数生成。 123456function isSymbol(value) &#123; const type = typeof value return type == 'symbol' || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Symbol]')&#125; 会发现 (isObjectLike(value) &amp;&amp; getTag(value) == &#39;[object Symbol]&#39;)，也对 Symbol 对象进行检测，但是如果直接 new Symbol 会 log 出 TypeError。 那么 lodash 为什么要对其进行检测，原来是创建一个显式包装器对象从 ECMAScript 6 开始不再被支持，现在可以利用如下代码来模拟，虽然没什么用。 1234const sym = Symbol("foo");typeof sym; // "symbol"const symObj = Object(sym);typeof symObj; // "object" UndefinedUndefined 类型只有一个值，即特殊的 undefined。在使用 let 或 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。 123function isUndefined(value) &#123; return value === undefined;&#125; NullNull 类型是只有一个值的数据类型，这个特殊的值是 null 。与 undefined 不同的是，它是一个字面量，而 undefined 是全局对象的一个属性。 从逻辑角度来看，null 值表示一个空对象指针，null 是表示缺少的标识，指示变量未指向任何对象。而这也正是使用typeof 操作符检测null 值时会返回”object”的原因。 对其的判断也非常的简单，只需要 123function isNull(value) &#123; return value === null&#125; 当然你也可以使用 12console.log(Object.prototype.toString.call(null))// [object Null] 以上是基本数据类型的判断，总结一下，主要是利用 typeOf 以及 Object.prototype.toString ，还有一些特殊值的特性。下面开始分析引用类型 Object 引用类型引用类型的值（对象）是引用类型的一个实例。在ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。具体的有 Object 、Array、Date、Error、RegExp、Function，还有ES2015 引入 Set、Map、WeakSet、WeakMap。 ObjectECMAScript 中的对象其实就是一组数据和功能的集合。它有一个很重要的用途，就是在 JavaScript 中的所有对象都来自 Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。即在ECMAScript 中，Object 类型是所有它的实例的基础。 所以 Lodash 去判断 value 是否为 Object 时，只使用了 typeOf 操作即可。 12345function isObject(value) &#123; const type = typeof value return value != null &amp;&amp; (type == 'object' || type == 'function')&#125; FunctionFunction 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。 1234567891011function isFunction(value) &#123; if (!isObject(value)) &#123; return false &#125; const tag = getTag(value) return tag == '[object Function]' || tag == '[object AsyncFunction]' || tag == '[object GeneratorFunction]' || tag == '[object Proxy]'&#125; 有个问题，typeOf 可以检测 Function对象的类型为 Function， 那为什么还需要 Object.prototype.toString 呢？ // in Safari 9 which returns ‘object’ for typed arrays and other constructors. ArrayArray 在 ECMAScript 中代表数组，它的每一项可以保存任何类型的数据。 对它的常规检测就是 Array.isArray，Lodash 也是使用这个 API，如果需要 Polyfill 方案的话，可以使用 1234// plan 1Object.prototype.toString.call(value) === '[object Array]'// plan 2value.constructor === Array 之前还有 value instanceof Array 会什么问题么？ 在存在不同全局变量的环境，通过语义 instanceof 检测数组的时候，value instanceof Array只有当 value 是由该页面的原始 Array 构造函数创建的数组时才能正常工作。 具体请见，http://web.mit.edu/jwalden/www/isArray.html。 DateECMAScript 中的 Date 类型是在早期Java 中的java.util.Date 类基础上构建的。 12345const nodeIsDate = nodeTypes &amp;&amp; nodeTypes.isDateconst isDate = nodeIsDate ? (value) =&gt; nodeIsDate(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Date]' Lodash 分为两个环境来处理这个问题，如果是 Node 就利用 util.types.isDate(value) 来检测，如果是在游览器，就还是通过 Object.prototype.toString 来判断。 SetES2015 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 123const isSet = nodeIsSet ? (value) =&gt; nodeIsSet(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Set]' 同样的还有 Map 123const isMap = nodeIsMap ? (value) =&gt; nodeIsMap(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Map]' WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 123function isWeakSet(value) &#123; return isObjectLike(value) &amp;&amp; getTag(value) == '[object WeakSet]'&#125; 也是利用 Object.prototype.toString ，同样还有 WeakMap 123function isWeakMap(value) &#123; return isObjectLike(value) &amp;&amp; getTag(value) == '[object WeakMap]'&#125; Error当运行时错误产生时，Error的实例对象会被抛出。 12345678910function isError(value) &#123; if (!isObjectLike(value)) &#123; return false &#125; const tag = getTag(value) return tag == '[object Error]' || tag == '[object DOMException]' || (typeof value.message == 'string' &amp;&amp; typeof value.name == 'string' &amp;&amp; !isPlainObject(value))&#125; 有之前一致的 Object.prototype.toString 依然可以用来判断对象是否是一个 Error，除此之外，如果对象满足以下条件，也可以被视为一个 Error 具备 message、name 属性，且值为 string； 是普通对象。 也就是说该对象由 Object 构造函数创建，或者 [[Prototype]] 为 null 。 那么如何检测普通对象呢? 12345678910111213function isPlainObject(value) &#123; if (!isObjectLike(value) || getTag(value) != '[object Object]') &#123; return false &#125; if (Object.getPrototypeOf(value) === null) &#123; return true &#125; let proto = value while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(value) === proto&#125; 主要是利用 Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值），同时和 value 本身的 [[Prototype]] 做判断。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 动态组件 & 异步组件原理]]></title>
    <url>%2F2019%2F07%2F19%2Fvue-dynamic-components%2F</url>
    <content type="text"><![CDATA[动态组件 &amp; 异步组件的存在，使得我们更方便地控制首屏代码的体积，加快加载速度。 抛开具体细节不谈，一个普通 Vue 组件从创建到展现在页面里，主要经历了以下流程： 123456789// 组件 Object&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;// 经过 compileToFunctions 得到对应的 render function with(this) &#123; return _c('div', [_v("I am async!")])&#125;// 在经过 render 得到 Vnode 再 update 成为真实DOM 动态组件&amp;异步组件与之有什么区别呢？ 主要区别在于 render 中 createComponent 这一步，举例。 1234// 组件Vue.component('example', &#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;) 普通组件在 createComponent 时，会依据开发者自定义的 options，利用 Vue.extend 生成对应的构造函数，从而得到对应的 Vnode 。而一个异步组件 12345678910// 异步组件Vue.component('async-example', function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 则是要经过一系列处理，具体过程如下 在源码的 create-component。 123456789101112131415161718// async componentlet asyncFactoryif (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125;&#125; 首先 Ctor 就与之前不同，这里为一个 function 123456789function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125; 之后调用 resolveAsyncComponent(asyncFactory, baseCtor, context) resolveAsyncComponent 在源码的 resolveAsyncComponent。 resolveAsyncComponent 的主要功能是定义 Ctor 所需要的 resolve 、reject 函数 12// factory 为 Ctorfactory(resolve, reject) 以 resolve 函数为例 12345678const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // 缓存 resolved factory.resolved = ensureCtor(res, baseCtor) // 强制渲染 if (!sync) &#123; forceRender(true) &#125;&#125;) once 字面理解，就是只调用一次。当 Ctor 中 setTimeout 结束时调用。 ensureCtor 就是 Vue.extend 的封装以适应不同场景，所以 resolve 函数的主要功能就是在异步完成时，将得到的 Ctor 转化为构造函数，缓存在 factory.resolved 中。 之后利用 forceRender(true) 强制重新 render，由于之前缓存了 factory.resolved，resolveAsyncComponent 函数就直接返回了组件的构造函数。 123if (isDef(factory.resolved)) &#123; return factory.resolved&#125; 之后就与普通组件一致了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解异步编程的原理]]></title>
    <url>%2F2019%2F07%2F18%2Funderstand-async-programming%2F</url>
    <content type="text"><![CDATA[异步的高性能为 Node 带来了高度的赞誉，而异步编程也为其带来了部分的诋毁。 异步编程从早期的 callback、事件发布\订阅模式到 ES6 的 Promise、Generator 在到 ES2017 中 async，看似风格迥异，但是还是有一条暗线将它们串联在一起的，就是希望将异步编程的代码表达尽量地贴合自然语言的线性思维。 以这条暗线将上述几种解决方案连在一起，就可以更好地理解异步编程的原理、魅力。 ├── 事件发布\订阅模式 &lt;= Callback ├── Promise &lt;= 事件发布\订阅模式 ├── Async、Await &lt;= Promise、Generator 事件发布\订阅模式 &lt;= Callback这个模式本质上就是回调函数的事件化。它本身并无同步、异步调用的问题，我们只是使用它来实现事件与回调函数之间的关联。比较典型的有 NodeJS 的 events 模块 12345678const &#123; EventEmitter &#125; = require('events')const eventEmitter = new EventEmitter()// 订阅eventEmitter.on("event", function(msg) &#123; console.log("event", msg)&#125;)// 发布eventEmitter.emit("event", "Hello world") 那么这种模式是如何与 Callback 关联的呢？我们可以利用 Javascript 简单实现 EventEmitter，答案就显而易见了。 123456789101112131415161718192021222324252627282930class usrEventEmitter &#123; constructor () &#123; this.listeners = &#123;&#125; &#125; // 订阅，callback 为每个 event 的侦听器 on(eventName, callback) &#123; if (!this.listeners[eventName]) this.listeners[eventName] = [] this.listeners[eventName].push(callback) &#125; // 发布 emit(eventName, params) &#123; this.listeners[eventName].forEach(callback =&gt; &#123; callback(params) &#125;) &#125; // 注销 off(eventName, callback) &#123; const rest = this.listeners[eventName].fitler(elem =&gt; elem !== callback) this.listeners[eventName] = rest &#125; // 订阅一次 once(eventName, callback) &#123; const handler = function() &#123; callback() this.off(eventName, handler) &#125; this.on(eventName, handler) &#125;&#125; 上述实现忽略了很多细节，例如异常处理、多参数传递等。只是为了展示事件订阅\发布模式。 很明显的看出，我们使用这种设计模式对异步编程做了逻辑上的分离，将其语义化为 1234// 一些事件可能会被触发eventEmitter.on// 当它发生的时候，要这样处理eventEmitter.emit 也就是说，我们将最初的 Callback 变成了事件监听器，从而优雅地解决异步编程。 Promise &lt;= 事件发布\订阅模式使用事件发布\订阅模式时，需要我们事先严谨地设置目标，也就是上面所说的，必须要缜密地设定好有哪些事件会发生。这与我们语言的线性思维很违和。那么有没有一种方式可以解决这个问题，社区产出了 Promise。 1234567891011const promise = new Promise(function(resolve, reject) &#123; try &#123; setTimeout(() =&gt; &#123; resolve('hello world') &#125;, 500) &#125; catch (error) &#123; reject(error) &#125;&#125;)// 语义就变为先发生一些异步行为，then 我们应该这么处理promise.then(msg =&gt; console.log(msg)).catch(error =&gt; console.log('err', error)) 那么这种 Promise 与事件发布\订阅模式有什么联系呢？我们可以利用 EventEmitter 来实现 Promise，这样可能会对你有所启发。 我们可以将 Promise 视为一个 EventEmitter，它包含了 { state: &#39;pending&#39; } 来描述当前的状态，同时侦听它的变化 当成功时 { state: &#39;fulfilled&#39; }，要做些什么 on(&#39;resolve&#39;, callback)； 当失败时 { state: &#39;rejected&#39; }，要做些什么 on(&#39;reject&#39;, callback)。 具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344const &#123; EventEmitter &#125; = require('events')class usrPromise extends EventEmitter &#123; // 构造时候执行 constructor(executor) &#123; super() // 发布 const resolve = (value) =&gt; this.emit('resolve', value) const reject = (reason) =&gt; this.emit('reject', reason) if (executor) &#123; // 模拟 event loop，注此处利用 Macrotask 来模拟 Microtask setTimeout(() =&gt; executor(resolve, reject)) &#125; &#125; then(resolveHandler, rejectHandler) &#123; const nextPromise = new usrPromise() // 订阅 resolve 事件 if (resolveHandler) &#123; const resolve = (data) =&gt; &#123; const result = resolveHandler(data) nextPromise.emit('resolve', result) &#125; this.on('resolve', resolve) &#125; // 订阅 reject 事件 if (rejectHandler) &#123; const reject = (data) =&gt; &#123; const result = rejectHandler(data) nextPromise.emit('reject', result) &#125; this.on('reject', reject) &#125; else &#123; this.on('reject', (data) =&gt; &#123; promise.emit('reject', data) &#125;) &#125; return nextPromise &#125; catch(handler) &#123; this.on('reject', handler) &#125;&#125; 引用于 https://gist.github.com/dmvaldman/12a7e46be6c3097aae31为了更好地模拟 Promise 机制，修改了一点。 如果需要进一步了解事件机制，见https://juejin.im/post/5c4041805188252420629086。 我们使用 then 方法来将预先需要定义的事件侦听器存放起来，同时在 executor 中设定这些事件该在什么时候实行。 可以看出从事件发布\订阅模式到 Promise，带来了语义上的巨大变革，但是还是需要使用 new Promise 来描述整个状态的转换，那么有没有更好地实现方式呢？ async、await &lt;= Promise、Generatorasync、await 标准是 ES 2017 引入，提供一种更加简洁的异步解决方案。 1234567891011121314async function say(greeting) &#123; return new Promise(function(resolve, then) &#123; setTimeout(function() &#123; resolve(greeting) &#125;, 1500) &#125;)&#125;;(async function() &#123; let v1 = await say('Hello') console.log(v1) let v2 = await say('World') console.log(v2)&#125;)() await 可以理解为暂停当前 async function 的执行，等待 Promise 处理完成。。若 Promise 正常处理（fulfilled），其回调的resolve函数参数作为 await 表达式的值。 async、await 的出现，减少了多个 then 的链式调用形式的代码。下面我们结合 Promise 与 Generator 来实现 async、await 123456789101112131415161718192021222324252627282930313233function async(makeGenerator) &#123; return function() &#123; const generator = makeGenerator.apply(this, arguments) function handle(&#123; value, done &#125;) &#123; if (done === true) return Promise.resolve(value) return Promise.resolve(value).then( (res) =&gt; &#123; return handle(generator.next(res)) &#125;, function(err) &#123; return handle(generator.throw(err)) &#125; ) &#125; try &#123; return handle(generator.next()) &#125; catch (ex) &#123; return Promise.reject(ex) &#125; &#125;&#125;async(function*() &#123; var v1 = yield say('hello') console.log(1, v1) var v2 = yield say('world') console.log(2, v2)&#125;)() 本质上就是利用递归完成 function* () { ... } 的自动执行。相比与 Generator 函数，这种形式无需手动执行，并且具有更好的语义。 引用： 深入浅出 NodeJS ES6 入门 PromiseJS]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React & Redux in TypeScript - 静态类型指南]]></title>
    <url>%2F2019%2F07%2F17%2Freact-in-ts%2F</url>
    <content type="text"><![CDATA[翻译自 react-redux-typescript-guide，作者：Piotrek Witek 翻译自 TypeScriptでRedux Thunkを使う，作责：Yusuke Mori 参考文章 TypeScript 2.8下的终极React组件模式 概述：最近在学习 react&amp;TypeScript，发现有许多的组件模式和方法需要去梳理和总结。所以选择一些文章用于沉淀和思考，记录下一些知识点，和大家探讨。 publish：2019-03-21 目录： 简介，环境配置（create-react-app） React - 关键类型（react-redux-typescript-guide ） React - 组件模式（react-redux-typescript-guide &amp; TypeScript 2.8下的终极React组件模式） Redux - 使用以及 Redux Thunk 使用（TypeScriptでRedux Thunkを使う） 总结 React - 关键类型 展示性组件（FunctionComponent） React.FunctionComponent&lt;P&gt; or React.FC&lt;P&gt;。 const MyComponent: React.FC&lt;Props&gt; = ... 有状态组件（ClassComponent） React.Component&lt;P, S&gt; class MyComponent extends React.Component&lt;Props, State&gt; { ... 组件Props React.ComponentProps&lt;typeof Component&gt; 获取组件（适用于ClassComponent、FunctionComponent）的Props的类型 type MyComponentProps = React.ComponentProps&lt;typeof MyComponent&gt;; React.FC | React.Component的联合类型 React.ComponentType&lt;P&gt; 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; &#123; ... React 要素 React.ReactElement&lt;P&gt; or JSX.Element 表示React元素概念的类型 - DOM组件（例如）或用户定义的复合组件（） const elementOnly: React.ReactElement = &lt;div /&gt; || &lt;MyComponent /&gt;; React Node React.ReactNode 表示任何类型的React节点（基本上是ReactElement（包括Fragments和Portals）+ 原始JS类型 的合集） 12const elementOrPrimitive: React.ReactNode = 'string' || 0 || false || null || undefined || &lt;div /&gt; || &lt;MyComponent /&gt;;const Component = (&#123; children: React.ReactNode &#125;) =&gt; ... React CSS属性 React.CSSProperties 代表着Style Object在 JSX 文件中（通常用于 css-in-js） 12const styles: React.CSSProperties = &#123; flexDirection: 'row', ...const element = &lt;div style=&#123;styles&#125; ... 通用的 React Event Handler React.ReactEventHandler&lt;HTMLElement&gt; 123const handleChange: React.ReactEventHandler&lt;HTMLInputElement&gt; = (ev) =&gt; &#123; ... &#125; &lt;input onChange=&#123;handleChange&#125; ... /&gt; 特殊的 React Event Handler React.MouseEvent&lt;E&gt; | React.KeyboardEvent&lt;E&gt; | React.TouchEvent&lt;E&gt; 123const handleChange = (ev: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; &#123; ... &#125;&lt;div onMouseMove=&#123;handleChange&#125; ... /&gt; React 组件模式 Function Components - FC 纯函数组件（无状态） 顾名思义，纯函数组件本身不具备 State，所以没有状态，一切通过 Props 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label: string, children: ReactElement, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 扩展属性（spread attributes） 利用 ... 对剩余属性进行处理 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent, CSSProperties &#125; from 'react'type Props = &#123; label: string, children: ReactElement, className?: string, style?: CSSProperties, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick, ...resetProps &#125;: Props) =&gt; &#123; return ( &lt;div &#123;...resetProps&#125;&gt; &lt;span&gt;&#123;label&#125;：&lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 默认属性 如果，需要默认属性，可以通过默认参数值来处理 123456789101112131415161718192021import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label?: string, children: ReactElement,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label = 'Hello', children &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button"&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent Class Components 相对于FC，多了 state，采用如下形式来定义Class Component 这一部分的写法，与TypeScript 2.8下的终极React组件模式相同，觉得结构很清晰，复用。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';type Props = &#123; label: string&#125;const initialState = &#123; count: 0&#125;type State = Readonly&lt;typeof initialState&gt;class ClassCounter extends Component&lt;Props, State&gt; &#123; readonly state: State = initialState private handleIncrement = () =&gt; this.setState(Increment) render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 默认属性 处理 Class Component 的默认属性，主要有两种方法： 一是定义高阶组件，例如TypeScript 2.8下的终极React组件模式中，利用 withDefaultProps 来定义默认属性，涉及组件的属性的类型转换； 二是利用 static props 以及 componentWillReceiveProps，处理默认属性。 具体业务中，视情况而定，第一中可以查看相关文章，这里介绍第二种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from 'react';type Props = &#123; label: string, initialCount: number&#125;type State = &#123; count: number;&#125;class ClassCounter extends Component&lt;Props, State&gt; &#123; static defaultProps = &#123; initialCount: 1, &#125; // 依据 defaultProps 对 state 进行处理 readonly state: State = &#123; count: this.props.initialCount, &#125; private handleIncrement = () =&gt; this.setState(Increment) // 响应 defaultProps 的变化 componentWillReceiveProps(&#123; initialCount &#125;: Props) &#123; if (initialCount != null &amp;&amp; initialCount !== this.props.initialCount) &#123; this.setState(&#123; count: initialCount &#125;) &#125; &#125; render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 通用组件 Generic Components 复用共有的逻辑创建组件 常用于通用列表 12345678910111213141516import React, &#123; Component, ReactElement &#125; from 'react'interface GenericListProps&lt;T&gt; &#123; items: T[], itemRenderer: (item: T, i: number) =&gt; ReactElement,&#125;class GenericList&lt;T&gt; extends Component&lt;GenericListProps&lt;T&gt;, &#123;&#125;&gt; &#123; render() &#123; const &#123; items, itemRenderer &#125; = this.props return &lt;div&gt;&#123;items.map(itemRenderer)&#125;&lt;/div&gt; &#125;&#125;export default GenericList Render Callback &amp; Render Props Render Callback，也被称为函数子组件，就是将 children 替换为 () =&gt; children； Render Props，就是将 () =&gt; component 作为 Props 传递下去。 1234567891011121314151617181920212223242526272829import React, &#123; Component, ReactElement &#125; from 'react';type Props = &#123; PropRender?: () =&gt; ReactElement, children?: () =&gt; ReactElement&#125;class PropRender extends Component&lt;Props, &#123;&#125;&gt; &#123; render() &#123; const &#123; props: &#123; children, PropRender &#125; &#125;: &#123; props: Props &#125; = this; return ( &lt;div&gt; &#123; PropRender &amp;&amp; PropRender() &#125; &#123; children &amp;&amp; children() &#125; &lt;/div&gt; ) &#125;&#125;export default PropRender// 应用&lt;PropsRender PropRender=&#123;() =&gt; (&lt;p&gt;Prop Render&lt;/p&gt;)&#125; &gt; &#123; () =&gt; (&lt;p&gt;Child Render&lt;/p&gt;) &#125; &lt;/PropsRender&gt; HOC（Higher-Order Components） 简单理解为，接受React组件作为输入，输出一个新的React组件的组件的工厂函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as React from 'react'interface InjectedProps &#123; label: string&#125;export const withState = &lt;BaseProps extends InjectedProps&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) =&gt; &#123; type HocProps = BaseProps &amp; InjectedProps &amp; &#123; initialCount?: number &#125; type HocState = &#123; readonly count: number &#125; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; // 方便 debugging in React-Dev-Tools static displayName = `withState($&#123;BaseComponent.name&#125;)`; // 关联原始的 wrapped component static readonly WrappedComponent = BaseComponent; readonly state: HocState = &#123; count: Number(this.props.initialCount) || 0, &#125; handleIncrement = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; const &#123; ...restProps &#125; = this.props as any const &#123; count &#125; = this.state return ( &lt;&gt; &#123;count&#125; &lt;BaseComponent onClick=&#123;this.handleIncrement&#125; &#123;...restProps&#125; /&gt; &lt;/&gt; ) &#125; &#125;&#125; Redux - 使用以及 Redux Thunk 使用以如下形式来介绍Redux，主要是in-ts的使用： (prestate, action) =&gt; state； 使用Redux Thunk 来出来异步操作。 123456789101112131415// store.jstype DataType = &#123; counter: number&#125;const DataState: DataType = &#123; counter: 0&#125;type RootState = &#123; Data: DataType&#125;export default RootState 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// action.jsimport &#123; Action, AnyAction &#125; from 'redux'import &#123; ThunkAction, ThunkDispatch &#125; from 'redux-thunk'import RootState from '../store/index'type IncrementPayload = &#123; value: number&#125;interface IncrementAction extends Action &#123; type: 'INCREMENT', payload: IncrementPayload&#125;export const Increment = (&#123; value &#125;: IncrementPayload): IncrementAction =&gt; &#123; const payload = &#123; value &#125; return &#123; type: 'INCREMENT', payload &#125;&#125;export type DecrementPayload = &#123; value: number;&#125;;export interface DecrementAction extends Action &#123; type: 'DECREMENT'; payload: DecrementPayload;&#125;export type RootAction = IncrementAction &amp; DecrementAction;export const asyncIncrement = ( payload: IncrementPayload): ThunkAction&lt;Promise&lt;void&gt;, RootState, void, AnyAction&gt; =&gt; &#123; return async (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): Promise&lt;void&gt; =&gt; &#123; return new Promise&lt;void&gt;((resolve) =&gt; &#123; console.log('Login in progress') setTimeout(() =&gt; &#123; dispatch(Increment(payload)) setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;, 3000) &#125;) &#125;&#125; 123456789101112131415// reducer.jsimport &#123; DataState, DataType &#125; from '../store/Data'import &#123; RootAction &#125; from '../actions/'export default function (state: DataType = DataState, &#123; type, payload &#125;: RootAction): DataType &#123; switch(type) &#123; case 'INCREMENT': return &#123; ...state, counter: state.counter + payload.value, &#125;; default: return state; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Hearder.jsimport React, &#123; Component, ReactNode &#125; from 'react'import RootState from '../store/index'import &#123; Dispatch, AnyAction &#125; from 'redux'import &#123; ThunkDispatch &#125; from 'redux-thunk'import &#123; connect &#125; from 'react-redux'import &#123; Increment, asyncIncrement &#125; from '../actions/'const initialState = &#123; name: 'string'&#125;type StateToPropsType = Readonly&lt;&#123; counter: number&#125;&gt;type DispatchToPropsType = Readonly&lt;&#123; handleAdd: () =&gt; void, handleDec: () =&gt; void&#125;&gt;type StateType = Readonly&lt;typeof initialState&gt;type PropsType = &#123; children?: ReactNode&#125;type ComponentProps = StateToPropsType &amp; DispatchToPropsType &amp; PropsTypeclass Header extends Component&lt;ComponentProps, StateType&gt; &#123; readonly state: StateType = initialState; render() &#123; const &#123; props: &#123; handleAdd, handleDec, counter &#125;, state: &#123; name &#125; &#125; = this return ( &lt;div&gt; 计数：&#123;counter&#125; &lt;button onClick=&#123;handleAdd&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;handleDec&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125; private handleClick = () =&gt; this.setState(sayHello);&#125;const sayHello = (prevState: StateType) =&gt; (&#123; name: prevState.name + 'Hello world',&#125;)const mapStateToProps = (state: RootState, props: PropsType): StateToPropsType =&gt; &#123; return &#123; counter: state.Data.counter &#125;&#125;const mapDispatchToProps = (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): DispatchToPropsType =&gt; &#123; return &#123; handleAdd: () =&gt; &#123; dispatch(Increment(&#123; value: 2 &#125;)) &#125;, handleDec: async () =&gt; &#123; dispatch(asyncIncrement(&#123; value: 10 &#125;)) &#125; &#125;&#125;export default connect&lt;StateToPropsType, DispatchToPropsType, PropsType, RootState&gt;(mapStateToProps, mapDispatchToProps)(Header)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
