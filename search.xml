<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 动态组件 & 异步组件原理]]></title>
    <url>%2F2019%2F07%2F19%2FVue-Dynamic-Components%2F</url>
    <content type="text"><![CDATA[动态组件 &amp; 异步组件的存在，使得我们更方便地控制首屏代码的体积，加快加载速度。 抛开具体细节不谈，一个普通 Vue 组件从创建到展现在页面里，主要经历了以下流程： 123456789// 组件 Object&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;// 经过 compileToFunctions 得到对应的 render function with(this) &#123; return _c('div', [_v("I am async!")])&#125;// 在经过 render 得到 Vnode 再 update 成为真实DOM 动态组件&amp;异步组件与之有什么区别呢？ 主要区别在于 render 中 createComponent 这一步，举例。 1234// 组件Vue.component('example', &#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;) 普通组件在 createComponent 时，会依据开发者自定义的 options，利用 Vue.extend 生成对应的构造函数，从而得到对应的 Vnode 。而一个异步组件 12345678910// 异步组件Vue.component('async-example', function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 则是要经过一系列处理，具体过程如下 在源码的 create-component。 123456789101112131415161718// async componentlet asyncFactoryif (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125;&#125; 首先 Ctor 就与之前不同，这里为一个 function 123456789function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125; 之后调用 resolveAsyncComponent(asyncFactory, baseCtor, context) resolveAsyncComponent 在源码的 resolveAsyncComponent。 resolveAsyncComponent 的主要功能是定义 Ctor 所需要的 resolve 、reject 函数 12// factory 为 Ctorfactory(resolve, reject) 以 resolve 函数为例 12345678const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // 缓存 resolved factory.resolved = ensureCtor(res, baseCtor) // 强制渲染 if (!sync) &#123; forceRender(true) &#125;&#125;) once 字面理解，就是只调用一次。当 Ctor 中 setTimeout 结束时调用。 ensureCtor 就是 Vue.extend 的封装以适应不同场景，所以 resolve 函数的主要功能就是在异步完成时，将得到的 Ctor 转化为构造函数，缓存在 factory.resolved 中。 之后利用 forceRender(true) 强制重新 render，由于之前缓存了 factory.resolved，resolveAsyncComponent 函数就直接返回了组件的构造函数。 123if (isDef(factory.resolved)) &#123; return factory.resolved&#125; 之后就与普通组件一致了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Components]]></title>
    <url>%2F2019%2F07%2F19%2FComponents%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[深入理解异步编程的原理]]></title>
    <url>%2F2019%2F07%2F18%2Funderstand-async-programming%2F</url>
    <content type="text"><![CDATA[异步的高性能为 Node 带来了高度的赞誉，而异步编程也为其带来了部分的诋毁。 异步编程从早期的 callback、事件发布\订阅模式到 ES6 的 Promise、Generator 在到 ES2017 中 async，看似风格迥异，但是还是有一条暗线将它们串联在一起的，就是希望将异步编程的代码表达尽量地贴合自然语言的线性思维。 以这条暗线将上述几种解决方案连在一起，就可以更好地理解异步编程的原理、魅力。 ├── 事件发布\订阅模式 &lt;= Callback ├── Promise &lt;= 事件发布\订阅模式 ├── Async、Await &lt;= Promise、Generator 事件发布\订阅模式 &lt;= Callback这个模式本质上就是回调函数的事件化。它本身并无同步、异步调用的问题，我们只是使用它来实现事件与回调函数之间的关联。比较典型的有 NodeJS 的 events 模块 12345678const &#123; EventEmitter &#125; = require('events')const eventEmitter = new EventEmitter()// 订阅eventEmitter.on("event", function(msg) &#123; console.log("event", msg)&#125;)// 发布eventEmitter.emit("event", "Hello world") 那么这种模式是如何与 Callback 关联的呢？我们可以利用 Javascript 简单实现 EventEmitter，答案就显而易见了。 123456789101112131415161718192021222324252627282930class usrEventEmitter &#123; constructor () &#123; this.listeners = &#123;&#125; &#125; // 订阅，callback 为每个 event 的侦听器 on(eventName, callback) &#123; if (!this.listeners[eventName]) this.listeners[eventName] = [] this.listeners[eventName].push(callback) &#125; // 发布 emit(eventName, params) &#123; this.listeners[eventName].forEach(callback =&gt; &#123; callback(params) &#125;) &#125; // 注销 off(eventName, callback) &#123; const rest = this.listeners[eventName].fitler(elem =&gt; elem !== callback) this.listeners[eventName] = rest &#125; // 订阅一次 once(eventName, callback) &#123; const handler = function() &#123; callback() this.off(eventName, handler) &#125; this.on(eventName, handler) &#125;&#125; 上述实现忽略了很多细节，例如异常处理、多参数传递等。只是为了展示事件订阅\发布模式。 很明显的看出，我们使用这种设计模式对异步编程做了逻辑上的分离，将其语义化为 1234// 一些事件可能会被触发eventEmitter.on// 当它发生的时候，要这样处理eventEmitter.emit 也就是说，我们将最初的 Callback 变成了事件监听器，从而优雅地解决异步编程。 Promise &lt;= 事件发布\订阅模式使用事件发布\订阅模式时，需要我们事先严谨地设置目标，也就是上面所说的，必须要缜密地设定好有哪些事件会发生。这与我们语言的线性思维很违和。那么有没有一种方式可以解决这个问题，社区产出了 Promise。 1234567891011const promise = new Promise(function(resolve, reject) &#123; try &#123; setTimeout(() =&gt; &#123; resolve('hello world') &#125;, 500) &#125; catch (error) &#123; reject(error) &#125;&#125;)// 语义就变为先发生一些异步行为，then 我们应该这么处理promise.then(msg =&gt; console.log(msg)).catch(error =&gt; console.log('err', error)) 那么这种 Promise 与事件发布\订阅模式有什么联系呢？我们可以利用 EventEmitter 来实现 Promise，这样可能会对你有所启发。 我们可以将 Promise 视为一个 EventEmitter，它包含了 { state: &#39;pending&#39; } 来描述当前的状态，同时侦听它的变化 当成功时 { state: &#39;fulfilled&#39; }，要做些什么 on(&#39;resolve&#39;, callback)； 当失败时 { state: &#39;rejected&#39; }，要做些什么 on(&#39;reject&#39;, callback)。 具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344const &#123; EventEmitter &#125; = require('events')class usrPromise extends EventEmitter &#123; // 构造时候执行 constructor(executor) &#123; super() // 发布 const resolve = (value) =&gt; this.emit('resolve', value) const reject = (reason) =&gt; this.emit('reject', reason) if (executor) &#123; // 模拟 event loop，注此处利用 Macrotask 来模拟 Microtask setTimeout(() =&gt; executor(resolve, reject)) &#125; &#125; then(resolveHandler, rejectHandler) &#123; const nextPromise = new usrPromise() // 订阅 resolve 事件 if (resolveHandler) &#123; const resolve = (data) =&gt; &#123; const result = resolveHandler(data) nextPromise.emit('resolve', result) &#125; this.on('resolve', resolve) &#125; // 订阅 reject 事件 if (rejectHandler) &#123; const reject = (data) =&gt; &#123; const result = rejectHandler(data) nextPromise.emit('reject', result) &#125; this.on('reject', reject) &#125; else &#123; this.on('reject', (data) =&gt; &#123; promise.emit('reject', data) &#125;) &#125; return nextPromise &#125; catch(handler) &#123; this.on('reject', handler) &#125;&#125; 引用于 https://gist.github.com/dmvaldman/12a7e46be6c3097aae31为了更好地模拟 Promise 机制，修改了一点。 如果需要进一步了解事件机制，见https://juejin.im/post/5c4041805188252420629086。 我们使用 then 方法来将预先需要定义的事件侦听器存放起来，同时在 executor 中设定这些事件该在什么时候实行。 可以看出从事件发布\订阅模式到 Promise，带来了语义上的巨大变革，但是还是需要使用 new Promise 来描述整个状态的转换，那么有没有更好地实现方式呢？ async、await &lt;= Promise、Generatorasync、await 标准是 ES 2017 引入，提供一种更加简洁的异步解决方案。 1234567891011121314async function say(greeting) &#123; return new Promise(function(resolve, then) &#123; setTimeout(function() &#123; resolve(greeting) &#125;, 1500) &#125;)&#125;;(async function() &#123; let v1 = await say('Hello') console.log(v1) let v2 = await say('World') console.log(v2)&#125;)() await 可以理解为暂停当前 async function 的执行，等待 Promise 处理完成。。若 Promise 正常处理（fulfilled），其回调的resolve函数参数作为 await 表达式的值。 async、await 的出现，减少了多个 then 的链式调用形式的代码。下面我们结合 Promise 与 Generator 来实现 async、await 123456789101112131415161718192021222324252627282930313233function async(makeGenerator) &#123; return function() &#123; const generator = makeGenerator.apply(this, arguments) function handle(&#123; value, done &#125;) &#123; if (done === true) return Promise.resolve(value) return Promise.resolve(value).then( (res) =&gt; &#123; return handle(generator.next(res)) &#125;, function(err) &#123; return handle(generator.throw(err)) &#125; ) &#125; try &#123; return handle(generator.next()) &#125; catch (ex) &#123; return Promise.reject(ex) &#125; &#125;&#125;async(function*() &#123; var v1 = yield say('hello') console.log(1, v1) var v2 = yield say('world') console.log(2, v2)&#125;)() 本质上就是利用递归完成 function* () { ... } 的自动执行。相比与 Generator 函数，这种形式无需手动执行，并且具有更好的语义。 引用： 深入浅出 NodeJS ES6 入门 PromiseJS]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React & Redux in TypeScript - 静态类型指南]]></title>
    <url>%2F2019%2F07%2F17%2Freact-in-ts%2F</url>
    <content type="text"><![CDATA[翻译自 react-redux-typescript-guide，作者：Piotrek Witek 翻译自 TypeScriptでRedux Thunkを使う，作责：Yusuke Mori 参考文章 TypeScript 2.8下的终极React组件模式 概述：最近在学习 react&amp;TypeScript，发现有许多的组件模式和方法需要去梳理和总结。所以选择一些文章用于沉淀和思考，记录下一些知识点，和大家探讨。 publish：2019-03-21 目录： 简介，环境配置（create-react-app） React - 关键类型（react-redux-typescript-guide ） React - 组件模式（react-redux-typescript-guide &amp; TypeScript 2.8下的终极React组件模式） Redux - 使用以及 Redux Thunk 使用（TypeScriptでRedux Thunkを使う） 总结 React - 关键类型 展示性组件（FunctionComponent） React.FunctionComponent&lt;P&gt; or React.FC&lt;P&gt;。 const MyComponent: React.FC&lt;Props&gt; = ... 有状态组件（ClassComponent） React.Component&lt;P, S&gt; class MyComponent extends React.Component&lt;Props, State&gt; { ... 组件Props React.ComponentProps&lt;typeof Component&gt; 获取组件（适用于ClassComponent、FunctionComponent）的Props的类型 type MyComponentProps = React.ComponentProps&lt;typeof MyComponent&gt;; React.FC | React.Component的联合类型 React.ComponentType&lt;P&gt; 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; &#123; ... React 要素 React.ReactElement&lt;P&gt; or JSX.Element 表示React元素概念的类型 - DOM组件（例如）或用户定义的复合组件（） const elementOnly: React.ReactElement = &lt;div /&gt; || &lt;MyComponent /&gt;; React Node React.ReactNode 表示任何类型的React节点（基本上是ReactElement（包括Fragments和Portals）+ 原始JS类型 的合集） 12const elementOrPrimitive: React.ReactNode = 'string' || 0 || false || null || undefined || &lt;div /&gt; || &lt;MyComponent /&gt;;const Component = (&#123; children: React.ReactNode &#125;) =&gt; ... React CSS属性 React.CSSProperties 代表着Style Object在 JSX 文件中（通常用于 css-in-js） 12const styles: React.CSSProperties = &#123; flexDirection: 'row', ...const element = &lt;div style=&#123;styles&#125; ... 通用的 React Event Handler React.ReactEventHandler&lt;HTMLElement&gt; 123const handleChange: React.ReactEventHandler&lt;HTMLInputElement&gt; = (ev) =&gt; &#123; ... &#125; &lt;input onChange=&#123;handleChange&#125; ... /&gt; 特殊的 React Event Handler React.MouseEvent&lt;E&gt; | React.KeyboardEvent&lt;E&gt; | React.TouchEvent&lt;E&gt; 123const handleChange = (ev: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; &#123; ... &#125;&lt;div onMouseMove=&#123;handleChange&#125; ... /&gt; React 组件模式 Function Components - FC 纯函数组件（无状态） 顾名思义，纯函数组件本身不具备 State，所以没有状态，一切通过 Props 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label: string, children: ReactElement, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 扩展属性（spread attributes） 利用 ... 对剩余属性进行处理 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent, CSSProperties &#125; from 'react'type Props = &#123; label: string, children: ReactElement, className?: string, style?: CSSProperties, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick, ...resetProps &#125;: Props) =&gt; &#123; return ( &lt;div &#123;...resetProps&#125;&gt; &lt;span&gt;&#123;label&#125;：&lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 默认属性 如果，需要默认属性，可以通过默认参数值来处理 123456789101112131415161718192021import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label?: string, children: ReactElement,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label = 'Hello', children &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button"&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent Class Components 相对于FC，多了 state，采用如下形式来定义Class Component 这一部分的写法，与TypeScript 2.8下的终极React组件模式相同，觉得结构很清晰，复用。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';type Props = &#123; label: string&#125;const initialState = &#123; count: 0&#125;type State = Readonly&lt;typeof initialState&gt;class ClassCounter extends Component&lt;Props, State&gt; &#123; readonly state: State = initialState private handleIncrement = () =&gt; this.setState(Increment) render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 默认属性 处理 Class Component 的默认属性，主要有两种方法： 一是定义高阶组件，例如TypeScript 2.8下的终极React组件模式中，利用 withDefaultProps 来定义默认属性，涉及组件的属性的类型转换； 二是利用 static props 以及 componentWillReceiveProps，处理默认属性。 具体业务中，视情况而定，第一中可以查看相关文章，这里介绍第二种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from 'react';type Props = &#123; label: string, initialCount: number&#125;type State = &#123; count: number;&#125;class ClassCounter extends Component&lt;Props, State&gt; &#123; static defaultProps = &#123; initialCount: 1, &#125; // 依据 defaultProps 对 state 进行处理 readonly state: State = &#123; count: this.props.initialCount, &#125; private handleIncrement = () =&gt; this.setState(Increment) // 响应 defaultProps 的变化 componentWillReceiveProps(&#123; initialCount &#125;: Props) &#123; if (initialCount != null &amp;&amp; initialCount !== this.props.initialCount) &#123; this.setState(&#123; count: initialCount &#125;) &#125; &#125; render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 通用组件 Generic Components 复用共有的逻辑创建组件 常用于通用列表 12345678910111213141516import React, &#123; Component, ReactElement &#125; from 'react'interface GenericListProps&lt;T&gt; &#123; items: T[], itemRenderer: (item: T, i: number) =&gt; ReactElement,&#125;class GenericList&lt;T&gt; extends Component&lt;GenericListProps&lt;T&gt;, &#123;&#125;&gt; &#123; render() &#123; const &#123; items, itemRenderer &#125; = this.props return &lt;div&gt;&#123;items.map(itemRenderer)&#125;&lt;/div&gt; &#125;&#125;export default GenericList Render Callback &amp; Render Props Render Callback，也被称为函数子组件，就是将 children 替换为 () =&gt; children； Render Props，就是将 () =&gt; component 作为 Props 传递下去。 1234567891011121314151617181920212223242526272829import React, &#123; Component, ReactElement &#125; from 'react';type Props = &#123; PropRender?: () =&gt; ReactElement, children?: () =&gt; ReactElement&#125;class PropRender extends Component&lt;Props, &#123;&#125;&gt; &#123; render() &#123; const &#123; props: &#123; children, PropRender &#125; &#125;: &#123; props: Props &#125; = this; return ( &lt;div&gt; &#123; PropRender &amp;&amp; PropRender() &#125; &#123; children &amp;&amp; children() &#125; &lt;/div&gt; ) &#125;&#125;export default PropRender// 应用&lt;PropsRender PropRender=&#123;() =&gt; (&lt;p&gt;Prop Render&lt;/p&gt;)&#125; &gt; &#123; () =&gt; (&lt;p&gt;Child Render&lt;/p&gt;) &#125; &lt;/PropsRender&gt; HOC（Higher-Order Components） 简单理解为，接受React组件作为输入，输出一个新的React组件的组件的工厂函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as React from 'react'interface InjectedProps &#123; label: string&#125;export const withState = &lt;BaseProps extends InjectedProps&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) =&gt; &#123; type HocProps = BaseProps &amp; InjectedProps &amp; &#123; initialCount?: number &#125; type HocState = &#123; readonly count: number &#125; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; // 方便 debugging in React-Dev-Tools static displayName = `withState($&#123;BaseComponent.name&#125;)`; // 关联原始的 wrapped component static readonly WrappedComponent = BaseComponent; readonly state: HocState = &#123; count: Number(this.props.initialCount) || 0, &#125; handleIncrement = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; const &#123; ...restProps &#125; = this.props as any const &#123; count &#125; = this.state return ( &lt;&gt; &#123;count&#125; &lt;BaseComponent onClick=&#123;this.handleIncrement&#125; &#123;...restProps&#125; /&gt; &lt;/&gt; ) &#125; &#125;&#125; Redux - 使用以及 Redux Thunk 使用以如下形式来介绍Redux，主要是in-ts的使用： (prestate, action) =&gt; state； 使用Redux Thunk 来出来异步操作。 123456789101112131415// store.jstype DataType = &#123; counter: number&#125;const DataState: DataType = &#123; counter: 0&#125;type RootState = &#123; Data: DataType&#125;export default RootState 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// action.jsimport &#123; Action, AnyAction &#125; from 'redux'import &#123; ThunkAction, ThunkDispatch &#125; from 'redux-thunk'import RootState from '../store/index'type IncrementPayload = &#123; value: number&#125;interface IncrementAction extends Action &#123; type: 'INCREMENT', payload: IncrementPayload&#125;export const Increment = (&#123; value &#125;: IncrementPayload): IncrementAction =&gt; &#123; const payload = &#123; value &#125; return &#123; type: 'INCREMENT', payload &#125;&#125;export type DecrementPayload = &#123; value: number;&#125;;export interface DecrementAction extends Action &#123; type: 'DECREMENT'; payload: DecrementPayload;&#125;export type RootAction = IncrementAction &amp; DecrementAction;export const asyncIncrement = ( payload: IncrementPayload): ThunkAction&lt;Promise&lt;void&gt;, RootState, void, AnyAction&gt; =&gt; &#123; return async (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): Promise&lt;void&gt; =&gt; &#123; return new Promise&lt;void&gt;((resolve) =&gt; &#123; console.log('Login in progress') setTimeout(() =&gt; &#123; dispatch(Increment(payload)) setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;, 3000) &#125;) &#125;&#125; 123456789101112131415// reducer.jsimport &#123; DataState, DataType &#125; from '../store/Data'import &#123; RootAction &#125; from '../actions/'export default function (state: DataType = DataState, &#123; type, payload &#125;: RootAction): DataType &#123; switch(type) &#123; case 'INCREMENT': return &#123; ...state, counter: state.counter + payload.value, &#125;; default: return state; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Hearder.jsimport React, &#123; Component, ReactNode &#125; from 'react'import RootState from '../store/index'import &#123; Dispatch, AnyAction &#125; from 'redux'import &#123; ThunkDispatch &#125; from 'redux-thunk'import &#123; connect &#125; from 'react-redux'import &#123; Increment, asyncIncrement &#125; from '../actions/'const initialState = &#123; name: 'string'&#125;type StateToPropsType = Readonly&lt;&#123; counter: number&#125;&gt;type DispatchToPropsType = Readonly&lt;&#123; handleAdd: () =&gt; void, handleDec: () =&gt; void&#125;&gt;type StateType = Readonly&lt;typeof initialState&gt;type PropsType = &#123; children?: ReactNode&#125;type ComponentProps = StateToPropsType &amp; DispatchToPropsType &amp; PropsTypeclass Header extends Component&lt;ComponentProps, StateType&gt; &#123; readonly state: StateType = initialState; render() &#123; const &#123; props: &#123; handleAdd, handleDec, counter &#125;, state: &#123; name &#125; &#125; = this return ( &lt;div&gt; 计数：&#123;counter&#125; &lt;button onClick=&#123;handleAdd&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;handleDec&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125; private handleClick = () =&gt; this.setState(sayHello);&#125;const sayHello = (prevState: StateType) =&gt; (&#123; name: prevState.name + 'Hello world',&#125;)const mapStateToProps = (state: RootState, props: PropsType): StateToPropsType =&gt; &#123; return &#123; counter: state.Data.counter &#125;&#125;const mapDispatchToProps = (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): DispatchToPropsType =&gt; &#123; return &#123; handleAdd: () =&gt; &#123; dispatch(Increment(&#123; value: 2 &#125;)) &#125;, handleDec: async () =&gt; &#123; dispatch(asyncIncrement(&#123; value: 10 &#125;)) &#125; &#125;&#125;export default connect&lt;StateToPropsType, DispatchToPropsType, PropsType, RootState&gt;(mapStateToProps, mapDispatchToProps)(Header)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
