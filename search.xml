<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Lodash 是如何做类型检测的]]></title>
    <url>%2F2019%2F07%2F21%2Fjs-type-detection%2F</url>
    <content type="text"><![CDATA[JS 的基本数据类型有 Number，String，Boolean，Symbol，Null，Undefined，六种数据类型。一种引用类型 object。 基本数据类型Number数值，根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。它并没有为整数给出一种特定的类型。 除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 对应 lodash 中的检测函数有 isNumber 检查 value 是否是原始 Number 数值型 或者 对象； isInteger 检查 value 是否为一个整数； isNaN 检测 value 是否为 NaN； isFinite 检测 value 是否是原始有限数值。 isNumber1234function isNumber(value) &#123; return typeof value == 'number' || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Number]')&#125; typeof 操作符可以返回一个字符串，表示未经计算的操作数的类型。对于 Number、String、Boolean、Undefined、String 可以很明确的得到它的类型。 那么 lodash 为什么还要添加 (isObjectLike(value) &amp;&amp; getTag(value) == &#39;[object Number]&#39;)？ 原因在于，JS 中也允许我们以如下形式创建一个数值 123const value = new Number(1)console.log(value) // log 1console.log(typeof value) // log "object" 这时，单单只是使用 typeof 操作符就没法判断 value 的类型是否为数值。所以要结合以下两个函数来判断，value 是否为 object 然后再通过过 toString() 来获取每个对象的类型。 12345678910function getTag(value) &#123; if (value == null) &#123; return value === undefined ? '[object Undefined]' : '[object Null]' &#125; return Object.prototype.toString.call(value) &#125;function isObjectLike(value) &#123; return typeof value == 'object' &amp;&amp; value !== null&#125; Object.prototype.toString.call 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。 isInteger12345function isInteger(value) &#123; return typeof value == 'number' &amp;&amp; value == toInteger(value);&#125; 检查 value 是否为一个整数，判断是否 value 的类型是否为数值，并且是否与 Int 型相同。其取整过程如下 1234567function toInteger(value) &#123; var result = toFinite(value), remainder = result % 1; return result === result ? (remainder ? result - remainder : result) : 0;&#125; isNaN检查 value 是否是 NaN。 123function isNaN(value) &#123; return isNumber(value) &amp;&amp; value != +value;&#125; 与 ES 2015 的 isNaN 不同的是，对于 undefined，{}，原生的结果是 true，而 lodash 为 false。这是因为如果isNaN函数的参数不是Number类型， isNaN函数会首先尝试将这个参数转换为数值，然后才会对转换后的结果是否是NaN进行判断。 12345// js native isNaNvar isNaN = function(value) &#123; var n = Number(value); return n !== n;&#125;; 但是无论是 ES 2015 还是 lodash，它们本质上都是利用 x != x 来判断 NaN。 isFinite检查 value 是否是原始有限数值。 1234function isFinite(value) &#123; return typeof value == 'number' &amp;&amp; nativeIsFinite(value);&#125; 利用原生的 isFinite 结合 typeof 判断数字是否为有限值。 StringString 类型用于表示由零或多个16 位Unicode 字符组成的字符序列，即字符串。用于保存可以以文本形式表示的数据非常有用。 值得注意的是，不单单要注意基本字符串，还需要注意字符串对象，字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。 JavaScript会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。 与之前的 number 类似，利用构造函数 String 创建的字符串是一个 object 12345const s_prim = "foo";const s_obj = new String(s_prim);console.log(typeof s_prim); // Logs "string"console.log(typeof s_obj); // Logs "object" 所以检测字符串，除了基本字符串以外还要注意字符串对象。 123456789function isString(value) &#123; const type = typeof value return type == 'string' || (type == 'object' &amp;&amp; value != null &amp;&amp; !Array.isArray(value) &amp;&amp; getTag(value) == '[object String]')&#125; 可以利用 typeof 检测基本字符串，对于模板字符串采用了之前介绍的方案 getTag 来获取 value 的类型。 BooleanBoolean 类型是ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。同样也需要区分基本的 Boolean 类型以及 Boolean 对象。 123456function isBoolean(value) &#123; return value === true || value === false || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Boolean]')&#125; 大部分在之前都已经涉及到了，这里出现了 isObjectLike，那么它是做什么的。 123function isObjectLike(value) &#123; return typeof value == 'object' &amp;&amp; value !== null&#125; 原来只是检测是否是一个非 null 的对象。 SymbolES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。Symbol 值通过Symbol函数生成。 123456function isSymbol(value) &#123; const type = typeof value return type == 'symbol' || (isObjectLike(value) &amp;&amp; getTag(value) == '[object Symbol]')&#125; 会发现 (isObjectLike(value) &amp;&amp; getTag(value) == &#39;[object Symbol]&#39;)，也对 Symbol 对象进行检测，但是如果直接 new Symbol 会 log 出 TypeError。 那么 lodash 为什么要对其进行检测，原来是创建一个显式包装器对象从 ECMAScript 6 开始不再被支持，现在可以利用如下代码来模拟，虽然没什么用。 1234const sym = Symbol("foo");typeof sym; // "symbol"const symObj = Object(sym);typeof symObj; // "object" UndefinedUndefined 类型只有一个值，即特殊的 undefined。在使用 let 或 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined。 123function isUndefined(value) &#123; return value === undefined;&#125; NullNull 类型是只有一个值的数据类型，这个特殊的值是 null 。与 undefined 不同的是，它是一个字面量，而 undefined 是全局对象的一个属性。 从逻辑角度来看，null 值表示一个空对象指针，null 是表示缺少的标识，指示变量未指向任何对象。而这也正是使用typeof 操作符检测null 值时会返回”object”的原因。 对其的判断也非常的简单，只需要 123function isNull(value) &#123; return value === null&#125; 当然你也可以使用 12console.log(Object.prototype.toString.call(null))// [object Null] 以上是基本数据类型的判断，总结一下，主要是利用 typeOf 以及 Object.prototype.toString ，还有一些特殊值的特性。下面开始分析引用类型 Object 引用类型引用类型的值（对象）是引用类型的一个实例。在ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。具体的有 Object 、Array、Date、Error、RegExp、Function，还有ES2015 引入 Set、Map、WeakSet、WeakMap。 ObjectECMAScript 中的对象其实就是一组数据和功能的集合。它有一个很重要的用途，就是在 JavaScript 中的所有对象都来自 Object；所有对象从Object.prototype继承方法和属性，尽管它们可能被覆盖。即在ECMAScript 中，Object 类型是所有它的实例的基础。 所以 Lodash 去判断 value 是否为 Object 时，只使用了 typeOf 操作即可。 12345function isObject(value) &#123; const type = typeof value return value != null &amp;&amp; (type == 'object' || type == 'function')&#125; FunctionFunction 构造函数 创建一个新的Function对象。 在 JavaScript 中, 每个函数实际上都是一个Function对象。 1234567891011function isFunction(value) &#123; if (!isObject(value)) &#123; return false &#125; const tag = getTag(value) return tag == '[object Function]' || tag == '[object AsyncFunction]' || tag == '[object GeneratorFunction]' || tag == '[object Proxy]'&#125; 有个问题，typeOf 可以检测 Function对象的类型为 Function， 那为什么还需要 Object.prototype.toString 呢？ // in Safari 9 which returns ‘object’ for typed arrays and other constructors. ArrayArray 在 ECMAScript 中代表数组，它的每一项可以保存任何类型的数据。 对它的常规检测就是 Array.isArray，Lodash 也是使用这个 API，如果需要 Polyfill 方案的话，可以使用 1234// plan 1Object.prototype.toString.call(value) === '[object Array]'// plan 2value.constructor === Array 之前还有 value instanceof Array 会什么问题么？ 在存在不同全局变量的环境，通过语义 instanceof 检测数组的时候，value instanceof Array只有当 value 是由该页面的原始 Array 构造函数创建的数组时才能正常工作。 具体请见，http://web.mit.edu/jwalden/www/isArray.html。 DateECMAScript 中的 Date 类型是在早期Java 中的java.util.Date 类基础上构建的。 12345const nodeIsDate = nodeTypes &amp;&amp; nodeTypes.isDateconst isDate = nodeIsDate ? (value) =&gt; nodeIsDate(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Date]' Lodash 分为两个环境来处理这个问题，如果是 Node 就利用 util.types.isDate(value) 来检测，如果是在游览器，就还是通过 Object.prototype.toString 来判断。 SetES2015 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 123const isSet = nodeIsSet ? (value) =&gt; nodeIsSet(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Set]' 同样的还有 Map 123const isMap = nodeIsMap ? (value) =&gt; nodeIsMap(value) : (value) =&gt; isObjectLike(value) &amp;&amp; getTag(value) == '[object Map]' WeakSetWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 123function isWeakSet(value) &#123; return isObjectLike(value) &amp;&amp; getTag(value) == '[object WeakSet]'&#125; 也是利用 Object.prototype.toString ，同样还有 WeakMap 123function isWeakMap(value) &#123; return isObjectLike(value) &amp;&amp; getTag(value) == '[object WeakMap]'&#125; Error当运行时错误产生时，Error的实例对象会被抛出。 12345678910function isError(value) &#123; if (!isObjectLike(value)) &#123; return false &#125; const tag = getTag(value) return tag == '[object Error]' || tag == '[object DOMException]' || (typeof value.message == 'string' &amp;&amp; typeof value.name == 'string' &amp;&amp; !isPlainObject(value))&#125; 有之前一致的 Object.prototype.toString 依然可以用来判断对象是否是一个 Error，除此之外，如果对象满足以下条件，也可以被视为一个 Error 具备 message、name 属性，且值为 string； 是普通对象。 也就是说该对象由 Object 构造函数创建，或者 [[Prototype]] 为 null 。 那么如何检测普通对象呢? 12345678910111213function isPlainObject(value) &#123; if (!isObjectLike(value) || getTag(value) != '[object Object]') &#123; return false &#125; if (Object.getPrototypeOf(value) === null) &#123; return true &#125; let proto = value while (Object.getPrototypeOf(proto) !== null) &#123; proto = Object.getPrototypeOf(proto) &#125; return Object.getPrototypeOf(value) === proto&#125; 主要是利用 Object.getPrototypeOf() 方法返回指定对象的原型（内部[[Prototype]]属性的值），同时和 value 本身的 [[Prototype]] 做判断。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 动态组件 & 异步组件原理]]></title>
    <url>%2F2019%2F07%2F19%2Fvue-dynamic-components%2F</url>
    <content type="text"><![CDATA[动态组件 &amp; 异步组件的存在，使得我们更方便地控制首屏代码的体积，加快加载速度。 抛开具体细节不谈，一个普通 Vue 组件从创建到展现在页面里，主要经历了以下流程： 123456789// 组件 Object&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;// 经过 compileToFunctions 得到对应的 render function with(this) &#123; return _c('div', [_v("I am async!")])&#125;// 在经过 render 得到 Vnode 再 update 成为真实DOM 动态组件&amp;异步组件与之有什么区别呢？ 主要区别在于 render 中 createComponent 这一步，举例。 1234// 组件Vue.component('example', &#123; template: '&lt;div&gt;I am async!&lt;/div&gt;'&#125;) 普通组件在 createComponent 时，会依据开发者自定义的 options，利用 Vue.extend 生成对应的构造函数，从而得到对应的 Vnode 。而一个异步组件 12345678910// 异步组件Vue.component('async-example', function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 则是要经过一系列处理，具体过程如下 在源码的 create-component。 123456789101112131415161718// async componentlet asyncFactoryif (isUndef(Ctor.cid)) &#123; asyncFactory = Ctor Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context) if (Ctor === undefined) &#123; // return a placeholder node for async component, which is rendered // as a comment node but preserves all the raw information for the node. // the information will be used for async server-rendering and hydration. return createAsyncPlaceholder( asyncFactory, data, context, children, tag ) &#125;&#125; 首先 Ctor 就与之前不同，这里为一个 function 123456789function (resolve, reject) &#123; // 利用 setTimeout 模拟请求 setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125; 之后调用 resolveAsyncComponent(asyncFactory, baseCtor, context) resolveAsyncComponent 在源码的 resolveAsyncComponent。 resolveAsyncComponent 的主要功能是定义 Ctor 所需要的 resolve 、reject 函数 12// factory 为 Ctorfactory(resolve, reject) 以 resolve 函数为例 12345678const resolve = once((res: Object | Class&lt;Component&gt;) =&gt; &#123; // 缓存 resolved factory.resolved = ensureCtor(res, baseCtor) // 强制渲染 if (!sync) &#123; forceRender(true) &#125;&#125;) once 字面理解，就是只调用一次。当 Ctor 中 setTimeout 结束时调用。 ensureCtor 就是 Vue.extend 的封装以适应不同场景，所以 resolve 函数的主要功能就是在异步完成时，将得到的 Ctor 转化为构造函数，缓存在 factory.resolved 中。 之后利用 forceRender(true) 强制重新 render，由于之前缓存了 factory.resolved，resolveAsyncComponent 函数就直接返回了组件的构造函数。 123if (isDef(factory.resolved)) &#123; return factory.resolved&#125; 之后就与普通组件一致了。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解异步编程的原理]]></title>
    <url>%2F2019%2F07%2F18%2Funderstand-async-programming%2F</url>
    <content type="text"><![CDATA[异步的高性能为 Node 带来了高度的赞誉，而异步编程也为其带来了部分的诋毁。 异步编程从早期的 callback、事件发布\订阅模式到 ES6 的 Promise、Generator 在到 ES2017 中 async，看似风格迥异，但是还是有一条暗线将它们串联在一起的，就是希望将异步编程的代码表达尽量地贴合自然语言的线性思维。 以这条暗线将上述几种解决方案连在一起，就可以更好地理解异步编程的原理、魅力。 ├── 事件发布\订阅模式 &lt;= Callback ├── Promise &lt;= 事件发布\订阅模式 ├── Async、Await &lt;= Promise、Generator 事件发布\订阅模式 &lt;= Callback这个模式本质上就是回调函数的事件化。它本身并无同步、异步调用的问题，我们只是使用它来实现事件与回调函数之间的关联。比较典型的有 NodeJS 的 events 模块 12345678const &#123; EventEmitter &#125; = require('events')const eventEmitter = new EventEmitter()// 订阅eventEmitter.on("event", function(msg) &#123; console.log("event", msg)&#125;)// 发布eventEmitter.emit("event", "Hello world") 那么这种模式是如何与 Callback 关联的呢？我们可以利用 Javascript 简单实现 EventEmitter，答案就显而易见了。 123456789101112131415161718192021222324252627282930class usrEventEmitter &#123; constructor () &#123; this.listeners = &#123;&#125; &#125; // 订阅，callback 为每个 event 的侦听器 on(eventName, callback) &#123; if (!this.listeners[eventName]) this.listeners[eventName] = [] this.listeners[eventName].push(callback) &#125; // 发布 emit(eventName, params) &#123; this.listeners[eventName].forEach(callback =&gt; &#123; callback(params) &#125;) &#125; // 注销 off(eventName, callback) &#123; const rest = this.listeners[eventName].fitler(elem =&gt; elem !== callback) this.listeners[eventName] = rest &#125; // 订阅一次 once(eventName, callback) &#123; const handler = function() &#123; callback() this.off(eventName, handler) &#125; this.on(eventName, handler) &#125;&#125; 上述实现忽略了很多细节，例如异常处理、多参数传递等。只是为了展示事件订阅\发布模式。 很明显的看出，我们使用这种设计模式对异步编程做了逻辑上的分离，将其语义化为 1234// 一些事件可能会被触发eventEmitter.on// 当它发生的时候，要这样处理eventEmitter.emit 也就是说，我们将最初的 Callback 变成了事件监听器，从而优雅地解决异步编程。 Promise &lt;= 事件发布\订阅模式使用事件发布\订阅模式时，需要我们事先严谨地设置目标，也就是上面所说的，必须要缜密地设定好有哪些事件会发生。这与我们语言的线性思维很违和。那么有没有一种方式可以解决这个问题，社区产出了 Promise。 1234567891011const promise = new Promise(function(resolve, reject) &#123; try &#123; setTimeout(() =&gt; &#123; resolve('hello world') &#125;, 500) &#125; catch (error) &#123; reject(error) &#125;&#125;)// 语义就变为先发生一些异步行为，then 我们应该这么处理promise.then(msg =&gt; console.log(msg)).catch(error =&gt; console.log('err', error)) 那么这种 Promise 与事件发布\订阅模式有什么联系呢？我们可以利用 EventEmitter 来实现 Promise，这样可能会对你有所启发。 我们可以将 Promise 视为一个 EventEmitter，它包含了 { state: &#39;pending&#39; } 来描述当前的状态，同时侦听它的变化 当成功时 { state: &#39;fulfilled&#39; }，要做些什么 on(&#39;resolve&#39;, callback)； 当失败时 { state: &#39;rejected&#39; }，要做些什么 on(&#39;reject&#39;, callback)。 具体实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344const &#123; EventEmitter &#125; = require('events')class usrPromise extends EventEmitter &#123; // 构造时候执行 constructor(executor) &#123; super() // 发布 const resolve = (value) =&gt; this.emit('resolve', value) const reject = (reason) =&gt; this.emit('reject', reason) if (executor) &#123; // 模拟 event loop，注此处利用 Macrotask 来模拟 Microtask setTimeout(() =&gt; executor(resolve, reject)) &#125; &#125; then(resolveHandler, rejectHandler) &#123; const nextPromise = new usrPromise() // 订阅 resolve 事件 if (resolveHandler) &#123; const resolve = (data) =&gt; &#123; const result = resolveHandler(data) nextPromise.emit('resolve', result) &#125; this.on('resolve', resolve) &#125; // 订阅 reject 事件 if (rejectHandler) &#123; const reject = (data) =&gt; &#123; const result = rejectHandler(data) nextPromise.emit('reject', result) &#125; this.on('reject', reject) &#125; else &#123; this.on('reject', (data) =&gt; &#123; promise.emit('reject', data) &#125;) &#125; return nextPromise &#125; catch(handler) &#123; this.on('reject', handler) &#125;&#125; 引用于 https://gist.github.com/dmvaldman/12a7e46be6c3097aae31为了更好地模拟 Promise 机制，修改了一点。 如果需要进一步了解事件机制，见https://juejin.im/post/5c4041805188252420629086。 我们使用 then 方法来将预先需要定义的事件侦听器存放起来，同时在 executor 中设定这些事件该在什么时候实行。 可以看出从事件发布\订阅模式到 Promise，带来了语义上的巨大变革，但是还是需要使用 new Promise 来描述整个状态的转换，那么有没有更好地实现方式呢？ async、await &lt;= Promise、Generatorasync、await 标准是 ES 2017 引入，提供一种更加简洁的异步解决方案。 1234567891011121314async function say(greeting) &#123; return new Promise(function(resolve, then) &#123; setTimeout(function() &#123; resolve(greeting) &#125;, 1500) &#125;)&#125;;(async function() &#123; let v1 = await say('Hello') console.log(v1) let v2 = await say('World') console.log(v2)&#125;)() await 可以理解为暂停当前 async function 的执行，等待 Promise 处理完成。。若 Promise 正常处理（fulfilled），其回调的resolve函数参数作为 await 表达式的值。 async、await 的出现，减少了多个 then 的链式调用形式的代码。下面我们结合 Promise 与 Generator 来实现 async、await 123456789101112131415161718192021222324252627282930313233function async(makeGenerator) &#123; return function() &#123; const generator = makeGenerator.apply(this, arguments) function handle(&#123; value, done &#125;) &#123; if (done === true) return Promise.resolve(value) return Promise.resolve(value).then( (res) =&gt; &#123; return handle(generator.next(res)) &#125;, function(err) &#123; return handle(generator.throw(err)) &#125; ) &#125; try &#123; return handle(generator.next()) &#125; catch (ex) &#123; return Promise.reject(ex) &#125; &#125;&#125;async(function*() &#123; var v1 = yield say('hello') console.log(1, v1) var v2 = yield say('world') console.log(2, v2)&#125;)() 本质上就是利用递归完成 function* () { ... } 的自动执行。相比与 Generator 函数，这种形式无需手动执行，并且具有更好的语义。 引用： 深入浅出 NodeJS ES6 入门 PromiseJS]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React & Redux in TypeScript - 静态类型指南]]></title>
    <url>%2F2019%2F07%2F17%2Freact-in-ts%2F</url>
    <content type="text"><![CDATA[翻译自 react-redux-typescript-guide，作者：Piotrek Witek 翻译自 TypeScriptでRedux Thunkを使う，作责：Yusuke Mori 参考文章 TypeScript 2.8下的终极React组件模式 概述：最近在学习 react&amp;TypeScript，发现有许多的组件模式和方法需要去梳理和总结。所以选择一些文章用于沉淀和思考，记录下一些知识点，和大家探讨。 publish：2019-03-21 目录： 简介，环境配置（create-react-app） React - 关键类型（react-redux-typescript-guide ） React - 组件模式（react-redux-typescript-guide &amp; TypeScript 2.8下的终极React组件模式） Redux - 使用以及 Redux Thunk 使用（TypeScriptでRedux Thunkを使う） 总结 React - 关键类型 展示性组件（FunctionComponent） React.FunctionComponent&lt;P&gt; or React.FC&lt;P&gt;。 const MyComponent: React.FC&lt;Props&gt; = ... 有状态组件（ClassComponent） React.Component&lt;P, S&gt; class MyComponent extends React.Component&lt;Props, State&gt; { ... 组件Props React.ComponentProps&lt;typeof Component&gt; 获取组件（适用于ClassComponent、FunctionComponent）的Props的类型 type MyComponentProps = React.ComponentProps&lt;typeof MyComponent&gt;; React.FC | React.Component的联合类型 React.ComponentType&lt;P&gt; 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; &#123; ... React 要素 React.ReactElement&lt;P&gt; or JSX.Element 表示React元素概念的类型 - DOM组件（例如）或用户定义的复合组件（） const elementOnly: React.ReactElement = &lt;div /&gt; || &lt;MyComponent /&gt;; React Node React.ReactNode 表示任何类型的React节点（基本上是ReactElement（包括Fragments和Portals）+ 原始JS类型 的合集） 12const elementOrPrimitive: React.ReactNode = 'string' || 0 || false || null || undefined || &lt;div /&gt; || &lt;MyComponent /&gt;;const Component = (&#123; children: React.ReactNode &#125;) =&gt; ... React CSS属性 React.CSSProperties 代表着Style Object在 JSX 文件中（通常用于 css-in-js） 12const styles: React.CSSProperties = &#123; flexDirection: 'row', ...const element = &lt;div style=&#123;styles&#125; ... 通用的 React Event Handler React.ReactEventHandler&lt;HTMLElement&gt; 123const handleChange: React.ReactEventHandler&lt;HTMLInputElement&gt; = (ev) =&gt; &#123; ... &#125; &lt;input onChange=&#123;handleChange&#125; ... /&gt; 特殊的 React Event Handler React.MouseEvent&lt;E&gt; | React.KeyboardEvent&lt;E&gt; | React.TouchEvent&lt;E&gt; 123const handleChange = (ev: React.MouseEvent&lt;HTMLDivElement&gt;) =&gt; &#123; ... &#125;&lt;div onMouseMove=&#123;handleChange&#125; ... /&gt; React 组件模式 Function Components - FC 纯函数组件（无状态） 顾名思义，纯函数组件本身不具备 State，所以没有状态，一切通过 Props 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label: string, children: ReactElement, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 扩展属性（spread attributes） 利用 ... 对剩余属性进行处理 12345678910111213141516171819202122import React, &#123; FC, ReactElement, MouseEvent, CSSProperties &#125; from 'react'type Props = &#123; label: string, children: ReactElement, className?: string, style?: CSSProperties, onClick?: (e: MouseEvent&lt;HTMLButtonElement&gt;) =&gt; void,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label, children, onClick, ...resetProps &#125;: Props) =&gt; &#123; return ( &lt;div &#123;...resetProps&#125;&gt; &lt;span&gt;&#123;label&#125;：&lt;/span&gt; &lt;button type="button" onClick=&#123;onClick&#125;&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent 默认属性 如果，需要默认属性，可以通过默认参数值来处理 123456789101112131415161718192021import React, &#123; FC, ReactElement, MouseEvent &#125; from 'react'type Props = &#123; label?: string, children: ReactElement,&#125;const FunctionComponent: FC&lt;Props&gt; = (&#123; label = 'Hello', children &#125;: Props) =&gt; &#123; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;： &lt;/span&gt; &lt;button type="button"&gt; &#123;children&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default FunctionComponent Class Components 相对于FC，多了 state，采用如下形式来定义Class Component 这一部分的写法，与TypeScript 2.8下的终极React组件模式相同，觉得结构很清晰，复用。 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; Component &#125; from 'react';type Props = &#123; label: string&#125;const initialState = &#123; count: 0&#125;type State = Readonly&lt;typeof initialState&gt;class ClassCounter extends Component&lt;Props, State&gt; &#123; readonly state: State = initialState private handleIncrement = () =&gt; this.setState(Increment) render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 默认属性 处理 Class Component 的默认属性，主要有两种方法： 一是定义高阶组件，例如TypeScript 2.8下的终极React组件模式中，利用 withDefaultProps 来定义默认属性，涉及组件的属性的类型转换； 二是利用 static props 以及 componentWillReceiveProps，处理默认属性。 具体业务中，视情况而定，第一中可以查看相关文章，这里介绍第二种 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component &#125; from 'react';type Props = &#123; label: string, initialCount: number&#125;type State = &#123; count: number;&#125;class ClassCounter extends Component&lt;Props, State&gt; &#123; static defaultProps = &#123; initialCount: 1, &#125; // 依据 defaultProps 对 state 进行处理 readonly state: State = &#123; count: this.props.initialCount, &#125; private handleIncrement = () =&gt; this.setState(Increment) // 响应 defaultProps 的变化 componentWillReceiveProps(&#123; initialCount &#125;: Props) &#123; if (initialCount != null &amp;&amp; initialCount !== this.props.initialCount) &#123; this.setState(&#123; count: initialCount &#125;) &#125; &#125; render() &#123; const &#123; handleIncrement &#125; = this; const &#123; label &#125; = this.props; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;/span&gt; &lt;button type="button" onClick=&#123;handleIncrement&#125;&gt; &#123;`Increment`&#125; &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export const Increment = (preState: State) =&gt; (&#123; count: preState.count + 1 &#125;)export default ClassCounter 通用组件 Generic Components 复用共有的逻辑创建组件 常用于通用列表 12345678910111213141516import React, &#123; Component, ReactElement &#125; from 'react'interface GenericListProps&lt;T&gt; &#123; items: T[], itemRenderer: (item: T, i: number) =&gt; ReactElement,&#125;class GenericList&lt;T&gt; extends Component&lt;GenericListProps&lt;T&gt;, &#123;&#125;&gt; &#123; render() &#123; const &#123; items, itemRenderer &#125; = this.props return &lt;div&gt;&#123;items.map(itemRenderer)&#125;&lt;/div&gt; &#125;&#125;export default GenericList Render Callback &amp; Render Props Render Callback，也被称为函数子组件，就是将 children 替换为 () =&gt; children； Render Props，就是将 () =&gt; component 作为 Props 传递下去。 1234567891011121314151617181920212223242526272829import React, &#123; Component, ReactElement &#125; from 'react';type Props = &#123; PropRender?: () =&gt; ReactElement, children?: () =&gt; ReactElement&#125;class PropRender extends Component&lt;Props, &#123;&#125;&gt; &#123; render() &#123; const &#123; props: &#123; children, PropRender &#125; &#125;: &#123; props: Props &#125; = this; return ( &lt;div&gt; &#123; PropRender &amp;&amp; PropRender() &#125; &#123; children &amp;&amp; children() &#125; &lt;/div&gt; ) &#125;&#125;export default PropRender// 应用&lt;PropsRender PropRender=&#123;() =&gt; (&lt;p&gt;Prop Render&lt;/p&gt;)&#125; &gt; &#123; () =&gt; (&lt;p&gt;Child Render&lt;/p&gt;) &#125; &lt;/PropsRender&gt; HOC（Higher-Order Components） 简单理解为，接受React组件作为输入，输出一个新的React组件的组件的工厂函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import * as React from 'react'interface InjectedProps &#123; label: string&#125;export const withState = &lt;BaseProps extends InjectedProps&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) =&gt; &#123; type HocProps = BaseProps &amp; InjectedProps &amp; &#123; initialCount?: number &#125; type HocState = &#123; readonly count: number &#125; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; // 方便 debugging in React-Dev-Tools static displayName = `withState($&#123;BaseComponent.name&#125;)`; // 关联原始的 wrapped component static readonly WrappedComponent = BaseComponent; readonly state: HocState = &#123; count: Number(this.props.initialCount) || 0, &#125; handleIncrement = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; const &#123; ...restProps &#125; = this.props as any const &#123; count &#125; = this.state return ( &lt;&gt; &#123;count&#125; &lt;BaseComponent onClick=&#123;this.handleIncrement&#125; &#123;...restProps&#125; /&gt; &lt;/&gt; ) &#125; &#125;&#125; Redux - 使用以及 Redux Thunk 使用以如下形式来介绍Redux，主要是in-ts的使用： (prestate, action) =&gt; state； 使用Redux Thunk 来出来异步操作。 123456789101112131415// store.jstype DataType = &#123; counter: number&#125;const DataState: DataType = &#123; counter: 0&#125;type RootState = &#123; Data: DataType&#125;export default RootState 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// action.jsimport &#123; Action, AnyAction &#125; from 'redux'import &#123; ThunkAction, ThunkDispatch &#125; from 'redux-thunk'import RootState from '../store/index'type IncrementPayload = &#123; value: number&#125;interface IncrementAction extends Action &#123; type: 'INCREMENT', payload: IncrementPayload&#125;export const Increment = (&#123; value &#125;: IncrementPayload): IncrementAction =&gt; &#123; const payload = &#123; value &#125; return &#123; type: 'INCREMENT', payload &#125;&#125;export type DecrementPayload = &#123; value: number;&#125;;export interface DecrementAction extends Action &#123; type: 'DECREMENT'; payload: DecrementPayload;&#125;export type RootAction = IncrementAction &amp; DecrementAction;export const asyncIncrement = ( payload: IncrementPayload): ThunkAction&lt;Promise&lt;void&gt;, RootState, void, AnyAction&gt; =&gt; &#123; return async (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): Promise&lt;void&gt; =&gt; &#123; return new Promise&lt;void&gt;((resolve) =&gt; &#123; console.log('Login in progress') setTimeout(() =&gt; &#123; dispatch(Increment(payload)) setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;, 3000) &#125;) &#125;&#125; 123456789101112131415// reducer.jsimport &#123; DataState, DataType &#125; from '../store/Data'import &#123; RootAction &#125; from '../actions/'export default function (state: DataType = DataState, &#123; type, payload &#125;: RootAction): DataType &#123; switch(type) &#123; case 'INCREMENT': return &#123; ...state, counter: state.counter + payload.value, &#125;; default: return state; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// Hearder.jsimport React, &#123; Component, ReactNode &#125; from 'react'import RootState from '../store/index'import &#123; Dispatch, AnyAction &#125; from 'redux'import &#123; ThunkDispatch &#125; from 'redux-thunk'import &#123; connect &#125; from 'react-redux'import &#123; Increment, asyncIncrement &#125; from '../actions/'const initialState = &#123; name: 'string'&#125;type StateToPropsType = Readonly&lt;&#123; counter: number&#125;&gt;type DispatchToPropsType = Readonly&lt;&#123; handleAdd: () =&gt; void, handleDec: () =&gt; void&#125;&gt;type StateType = Readonly&lt;typeof initialState&gt;type PropsType = &#123; children?: ReactNode&#125;type ComponentProps = StateToPropsType &amp; DispatchToPropsType &amp; PropsTypeclass Header extends Component&lt;ComponentProps, StateType&gt; &#123; readonly state: StateType = initialState; render() &#123; const &#123; props: &#123; handleAdd, handleDec, counter &#125;, state: &#123; name &#125; &#125; = this return ( &lt;div&gt; 计数：&#123;counter&#125; &lt;button onClick=&#123;handleAdd&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;handleDec&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125; private handleClick = () =&gt; this.setState(sayHello);&#125;const sayHello = (prevState: StateType) =&gt; (&#123; name: prevState.name + 'Hello world',&#125;)const mapStateToProps = (state: RootState, props: PropsType): StateToPropsType =&gt; &#123; return &#123; counter: state.Data.counter &#125;&#125;const mapDispatchToProps = (dispatch: ThunkDispatch&lt;RootState, void, AnyAction&gt;): DispatchToPropsType =&gt; &#123; return &#123; handleAdd: () =&gt; &#123; dispatch(Increment(&#123; value: 2 &#125;)) &#125;, handleDec: async () =&gt; &#123; dispatch(asyncIncrement(&#123; value: 10 &#125;)) &#125; &#125;&#125;export default connect&lt;StateToPropsType, DispatchToPropsType, PropsType, RootState&gt;(mapStateToProps, mapDispatchToProps)(Header)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
</search>
